<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="clixdoc.xsl" ?>
<clix:documentation xmlns="http://www.w3.org/1999/xhtml" xmlns:clix="http://bknr.net/clixdoc">

  <clix:title>HUNCHENTOOT - The Common Lisp web server formerly known as TBNL</clix:title>

  <clix:short-description>
    A fully-featured web server written in Common Lisp offering things
    like HTTP/1.1 chunking, persistent connections, and SSL.  Includes
    a framework for building dynamic websites interactively.
  </clix:short-description>

  <h2>
    <a href="http://www.htg1.de/hunchentoot/hunchentoot.html"
       title="Click here for the Hunchentoot logo"
       class="noborder">
      <img align="top" width="93" height="45" border="0" src="hunchentoot.gif" />
    </a>
    HUNCHENTOOT - The Common Lisp web server formerly known as TBNL
  </h2>

  <blockquote>

    <h3>
      <a name="abstract" class="none">Abstract</a>
    </h3>

    <p>
      Hunchentoot is a web server written in Common Lisp and at the
      same time a toolkit for building dynamic websites.  As a
      stand-alone web server, Hunchentoot is capable of HTTP/1.1
      chunking (both directions), persistent connections
      (keep-alive), and SSL.
    </p>
    <p>
      Hunchentoot provides facilities like automatic session
      handling (with and without cookies), logging, customizable
      error handling, and easy access to GET and POST parameters
      sent by the client. It does <em>not</em> include functionality
      to programmatically generate HTML output. For this task you
      can use any library you like, e.g. (shameless self-plug)
      <a href="http://weitz.de/cl-who/">CL-WHO</a> or
      <a href="http://weitz.de/html-template/">HTML-TEMPLATE</a>.
    </p>
    <p>
      Hunchentoot talks with its front-end or with the client over
      TCP/IP sockets and optionally uses multiprocessing to handle
      several requests at the same time.  Therefore, it cannot be
      implemented completely in
      <a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">portable
        Common Lisp</a>.  It currently works "natively" with 
      <a href="http://www.lispworks.com/">LispWorks</a> (which is the
      main development and testing platform), and additionally on all
      Lisps which are supported by the compatibility
      layers <a href="http://common-lisp.net/project/usocket/">usocket</a>
      and <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a>.
    </p>
    <p>
      Hunchentoot comes with a 
      <a href="http://www.opensource.org/licenses/bsd-license.php">BSD-style
        license</a> so you can basically do with it whatever you want.
    </p>
    <p>
      Hunchentoot is for example used by 
      <a href="http://www.thoughtcrime.us/tp/">Trip Planner</a>, 
      <a href="http://clutu.com/">clutu</a>, 
      <a href="http://twitterbuzz.com/">TwitterBuzz</a>, 
      <a href="http://www.jalat.com/">Jalat</a>, 
      <a href="http://heikestephan.de/">Heike Stephan</a>, 
      <a href="http://www.memetrics.com/">xOs</a>, and 
      <a href="http://syseng.nist.gov/moss">the</a> 
      <a href="http://syseng.nist.gov/se-interop">NIST</a>.
    </p>
    <p>
      <font color="red">Download shortcut:</font>
      <a href="http://weitz.de/files/hunchentoot.tar.gz">http://weitz.de/files/hunchentoot.tar.gz</a>.
    </p>
  </blockquote>

  <font color="red"><b>Note that the development version is pretty
  much in flux and this HTML documentation is not in sync with it.  If
  in doubt, check which symbols are exported, look at their
  docstrings, read the source, curse...</b></font>

  <h3>
    <a class="none" name="contents">Contents</a>
  </h3>

  <clix:contents/>

  <clix:chapter name="install" title="Download and installation">

    Hunchentoot depends on a couple of other Lisp libraries which you'll need
    to install first:
    <ul>
      <li>Pierre R. Mai's <a href="http://www.cliki.net/md5">MD5</a>,</li>
      <li>Kevin Rosenberg's <a href="http://www.cliki.net/cl-base64">CL-BASE64</a>,</li>
      <li>Janis Dzerins' <a href="http://common-lisp.net/project/rfc2388/">RFC2388</a>,</li>
      <li>Peter Seibel's <a href="http://weitz.de/cl-fad/">CL-FAD</a>,</li>
      <li>Erik Huelsmann's <a href="http://common-lisp.net/project/usocket">usocket</a> (unless you're using LispWorks),</li>
      <li>Greg Pfeil's <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
          Threads</a> (unless you're using LispWorks),
      </li>
      <li>
        David Lichteblau's <a href="http://common-lisp.net/project/cl-plus-ssl/">CL+SSL</a>
        (unless you're using LispWorks),
      </li>
      <li>
        and my own <a href="http://weitz.de/flexi-streams/">FLEXI-STREAMS</a> (0.12.0 or higher),
        <a href="http://weitz.de/chunga/">Chunga</a> (0.5.0 or
          higher), and <a href="http://weitz.de/cl-ppcre/">
          CL-PPCRE</a> (plus
        <a href="http://weitz.de/cl-who/">CL-WHO</a> for the <a href="#example">example code</a>). 
      </li>
    </ul>

    Make sure to use the <em>newest</em> versions of all of these
    libraries (which might themselves depend on other libraries) - try
    the repository versions if you're in doubt.  Note: You can compile
    Hunchentoot without SSL support - and thus without the need to
    have CL+SSL - if you add
    <code>:HUNCHENTOOT-NO-SSL</code> to
    <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm">
      <code>*FEATURES*</code></a> <em>before</em> you compile it.
    <p>
      Hunchentoot will only work with Lisps where
      the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#character_code">character
      codes</a> of
      all <a href="http://en.wikipedia.org/wiki/ISO_8859-1">Latin-1</a>
      characters coincide with their
      Unicode <a href="http://en.wikipedia.org/wiki/Code_point">code
      points</a> (which is the case for all current implementations I
      know).
    </p>
    <p>
      Hunchentoot itself together with this documentation can be
      downloaded from
      <a href="http://weitz.de/files/hunchentoot.tar.gz">http://weitz.de/files/hunchentoot.tar.gz</a>.
      The current version is 1.0.0.
    </p>
    <p>
      The preferred method to compile and load Hunchentoot is via
      <a href="http://www.cliki.net/asdf">ASDF</a>.  If you think that
      it's too much work to find and download all the libraries
      mentioned above, try something like
      <a href="http://common-lisp.net/project/asdf-install/">ASDF-INSTALL</a>,
      <a href="http://common-lisp.net/project/clbuild/">clbuild</a>,
      or my own <a href="http://weitz.de/starter-pack/">Starter
        Pack</a>.  There's also a port for
      <a href="http://www.gentoo.org/proj/en/common-lisp/index.xml">Gentoo
        Linux</a> thanks to Matthew Kennedy.
    </p>
    <p>
      A <a href="http://www.selenic.com/mercurial/wiki/">Mercurial</a>
      repository of older versions is available at
      <a href="http://arcanes.fr.eu.org/~pierre/2007/02/weitz/">http://arcanes.fr.eu.org/~pierre/2007/02/weitz/</a>
      thanks to Pierre Thierry.
    </p>
    <p>
      Luís Oliveira maintains a <a href="http://darcs.net/">darcs</a>
      repository of Hunchentoot at
      <a href="http://common-lisp.net/~loliveira/ediware/">http://common-lisp.net/~loliveira/ediware/</a>.
    </p>

    <clix:subchapter name="proxy" title="Hunchentoot behind a proxy">

      If you're feeling unsecure about exposing Hunchentoot to the wild,
      wild Internet or if your Lisp web application is part of a larger
      website, you can hide it behind a
      <a href="http://en.wikipedia.org/wiki/Proxy_server">proxy server</a>.
      One approach that I have used several times is to employ Apache's
      <a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html">mod_proxy</a>
      module with a configuration that looks like this:

<pre><a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html#proxypass" class="noborder">ProxyPass</a> /hunchentoot http://127.0.0.1:3000/hunchentoot
<a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html#proxypassreverse" class="noborder">ProxyPassReverse</a> /hunchentoot http://127.0.0.1:3000/hunchentoot</pre>

      This will tunnel all requests where the URI path begins with
      <code>"/hunchentoot"</code> to a (Hunchentoot) server listening on
      port 3000 on the same machine.

      <p>
        Of course, there are
        <a href="http://www.red-bean.com/pipermail/lispweb/2006-October/001342.html">several
          other</a> (more lightweight) web proxies that you could use
        instead of Apache.
      </p>
    </clix:subchapter>
  </clix:chapter>

  <clix:chapter name="mail" title="Support and mailing lists">

    For questions, bug reports, feature requests, improvements, or
    patches please use the
    <a href="http://common-lisp.net/mailman/listinfo/tbnl-devel">tbnl-devel
      mailing list</a>. If you want to be notified about future
    releases subscribe to the
    <a href="http://common-lisp.net/mailman/listinfo/tbnl-announce">tbnl-announce
      mailing list</a>. These mailing lists were made available thanks
    to the services of
    <a href="http://common-lisp.net/">common-lisp.net</a>.  You can
    <b>search</b> the devel mailing list
    <a href="http://google.com/coop/cse?cx=002927904911724867201%3A0l5rif_cxj0">here</a>
    (thanks to Tiarnán Ó Corráin).
    <p>
      If you want to send patches, please
      <a href="http://weitz.de/patches.html">read this first</a>.
    </p>
  </clix:chapter>

  <clix:chapter name="example" title="Examples, tutorials, add-ons">

    Hunchentoot comes with an example website which you can use to see
    if it works and which should also demonstrate a couple of the
    things you can do with Hunchentoot.  Use it as a kind of "Hello
    World" code to get yourself started.

    <p>
      To run the example, enter the following code into your listener:
    </p>

<pre>(<a class="noborder" href="http://common-lisp.net/~mmommer/asdf-howto.shtml#sec11">asdf:oos</a> 'asdf:load-op :hunchentoot-test)
(hunchentoot:<a class="noborder" href="#start-server">start-server</a> :port 4242)</pre>

    You should now be able to point your browser at
    <code>http://localhost:4242/hunchentoot/test</code> and see
    something.
    <p>
      Here are some tutorials done by others:
    </p>
    <ul>
      <li>
        <a href="http://www.adampetersen.se/articles/lispweb.htm">"Lisp for the Web"</a> by Adam Petersen.
      </li>
      <li>
        Two <a href="http://myblog.rsynnott.com/2007/09/getting-started-with-hunchento.html">getting</a>
        <a href="http://myblog.rsynnott.com/2007/10/doing-more-with-hunchentoot-cl-server.html">started</a>
        articles by Robert Synnott.
      </li>
      <li>
        <a href="http://www.newartisans.com/blog_files/common.lisp.with.apache.php">Running Common Lisp
          behind Apache</a> by John Wiegley.  (And there's a
        <a href="http://www.newartisans.com/blog_files/hunchentoot.primer.php">second part</a>.)
      </li>
      <li>
        A <a href="http://www.lispcast.com/index.php/2007/10/lispcast-writing-a-simple-reddit-clone-in-common-lisp/">"LispCast"</a>
        by Eric Normand about writing a <a href="http://reddit.com/">Reddit</a> clone using
        Hunchentoot.  Apparently the first part of a
        <a href="http://bc.tech.coop/blog/071028.html">series</a>.
      </li>
      <li>
        A <a href="http://dirtyhack.org/vetler/docs/cl-webapp-intro/part-1/">tutorial</a> about
        implementing a blog in Common Lisp by Vetle Roeim.
      </li>
      <li>
        A <a href="http://www.jalat.com/blogs/lisp?id=3">tutorial</a> for (an older version of)
        Hunchentoot by Asbjørn Bjørnstad.
      </li>
      <li>
        A <a href="http://www.frank-buss.de/lisp/tbnl.html">TBNL tutorial</a> from Frank Buss.
        (Hunchentoot is not <a href="http://weitz.de/tbnl/">TBNL</a>, but the two are similar enough
        to make the tutorial worthwhile.)
      </li>
      <li>
        For Win32, Bill
        Clementson <a href="http://bc.tech.coop/blog/041105.html">explains</a>
        how to set up Hunchentoot's
        predecessor <a href="http://weitz.de/tbnl/">TBNL</a> with
        Apache/mod_lisp.  See
        also <a href="http://bc.tech.coop/blog/061013.html">http://bc.tech.coop/blog/061013.html</a>.
      </li>
    </ul>

    Check the dates of these tutorials.  Some of them might not be a
    perfect fit with the latest release of Hunchentoot.  Also, the
    fact that these tutorials are listed here doesn't necessarily mean
    that I endorse them or think that they show idiomatic Lisp code.
    You'll have to decide yourself if they're helpful to you or not.

    <p>
      Here is some software which extends Hunchentoot or is based on it:
    </p>
    <ul>
      <li>
        <a href="http://common-lisp.net/project/cl-weblocks/">Weblocks</a>
        by Slava Akhmechet is a "continuations-based web framework" which is
        based on Hunchentoot.
      </li>
      <li>
        <a href="http://pen.two-bytes.com/misc/ht-ajax.html">HT-AJAX</a> is
        an <a href="http://en.wikipedia.org/wiki/Ajax_%28programming%29">Ajax</a>
        framework for Hunchentoot by Ury Marshak.
      </li>
      <li>
        Mac Chan
        <a href="http://common-lisp.net/pipermail/tbnl-devel/2007-May/001324.html">has
          ported <a href="http://lemonodor.com/">John Wiseman</a>'s
          <a href="http://www.lemonodor.com/archives/000128.html">Lisp
            Server Pages</a> to Hunchentoot.</a>
      </li>
      <li>
        <a href="http://site.znain.com/dl/lisp/hunchentoot-dir-lister/">hunchentoot-dir-lister</a>
        is a directory listing addition for Hunchentoot by Dimitre Liotev.
      </li>
      <li>
        Cyrus Harmon's
        <a href="http://cyrusharmon.org/blog/display?id=64">nuclblog</a> is a
        <a href="http://en.wikipedia.org/wiki/Blog">blog</a> engine which uses Hunchentoot.
      </li>
      <li>
        <a href="http://cyrusharmon.org/projects?project=hunchentoot-cgi">hunchentoot-cgi</a>
        (also by Cyrus Harmon) provides
        <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>
        handlers for Hunchentoot.
      </li>
      <li>
        <a href="http://weitz.de/cl-webdav/">CL-WEBDAV</a> is a <a href="http://webdav.org/">WebDAV</a>
        server based on Hunchentoot.
      </li>
    </ul>
  </clix:chapter>

  <clix:chapter name="reference" title="Function and variable reference">

    <clix:subchapter name="servers" title="Servers">

      If you want Hunchentoot to actually do something, you have to
      <a href="#start-server">start</a> a server.  You can also run
      several servers in one image, each one listening to a
      different port.

      <clix:function name="start-server">
        <clix:lambda-list>
          <clix:lkw>key</clix:lkw> port address dispatch-table name
          request-class input-chunking-p connection-timeout setuid
          setgid access-logger message-logger ssl-certificate-file
          ssl-privatekey-file ssl-privatekey-password
        </clix:lambda-list>
        <clix:returns>
          server
        </clix:returns>
        <clix:description>
          <p>
            Starts a Hunchentoot server instance and returns it.
            <clix:arg>port</clix:arg> is the port the server will be
            listening on - the default is 80 (or 443 if SSL information
            is provided).  If <clix:arg>address</clix:arg> is a string
            denoting an IP address, then the server only receives
            connections for that address.  This must be one of the
            addresses associated with the machine and allowed values are
            host names such as
            <a class="none" href="http://www.zappa.com/"><code>"www.zappa.com"</code></a>
            and address strings such as
            <a class="none" href="http://72.3.247.29/"><code>"72.3.247.29"</code></a>.

            If <clix:arg>address</clix:arg> is <code>NIL</code>, then the
            server will receive connections to all IP addresses on the
            machine.  This is the default.
          </p>
          <p>
            The <clix:arg>request-class</clix:arg> argument determines
            which class of request objects is created when a request
            comes in and should be (a symbol naming) a class which
            inherits from <clix:ref>REQUEST</clix:ref>.  The default is the symbol
            <code>REQUEST</code>.
          </p>
          <p>
            <clix:arg>dispatch-table</clix:arg> should be a
            <a href="#*dispatch-table*">dispatch table</a> which is to
            be used by this server or <code>NIL</code> which means that
            the value of the global variable <a href="#*dispatch-table*">
            <code>*DISPATCH-TABLE*</code></a> at request time will be
            used.  This argument is of course meaningless if you
            implement your own dispatch mechanism.
          </p>
          <p>
            <clix:arg>name</clix:arg> should be a symbol which can be used
            to name the server.  This name can be utilized when
            defining <a href="#define-easy-handler">easy handlers</a>.
            The default name is an uninterned symbol as returned
            by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_gensym.htm">
              <code>GENSYM</code></a>.
          </p>
          <p>
            If <clix:arg>input-chunking-p</clix:arg> is true (which is the
            default), the server will accept request bodies without
            a <code>Content-Length</code> header if the client uses
            chunked transfer encoding.
          </p>
          <p>
            <clix:arg>connection-timeout</clix:arg> is the timeout
            (in seconds) for the socket stream used by the server -
            the default value
            is <a href="#*default-connection-timeout*"> <code>*DEFAULT-READ-TIMEOUT*</code></a>.
            This parameter determines how long Hunchentoot will wait
            for input data to arrive or output data to be flushed on
            incoming connections.
          </p>
          <p>
            This parameter is not available on all platforms.  Its exact
            behavior is implementation dependent and one cannot rely on
            the <clix:arg>timeout</clix:arg> argument to specify a hard
            limit.
          </p>
          <p>
            <clix:arg>access-logger</clix:arg> specifies a designator
            for a function that Hunchentoot should call in order to
            log requests to the server.  The function must accept the
            keyword arguments RETURN-CODE, CONTENT and CONTENT-LENGTH
            which are set to the HTTP response code, the content sent
            back to the client and the length of the content,
            respectively.  The function may use standard request
            accessors to determine additional information about the
            request and its outcome.  By default, Hunchentoot sets
            this parameter to the name of a function that logs to a
            file.  See <clix:ref>ACCESS-LOG-FILE</clix:ref> for further
            information.  Set this parameter to <code>NIL</code> in order to
            suppress access logging altogether.
          </p>
          <p>
            <clix:arg>message-logger</clix:arg> specifies a function
            that Hunchentoot should call in order to log an error or
            other event.  The function must accept at least two
            arguments, the message severity code (one of <code>:INFO</code>,
            <code>:WARNING</code>, or <code>:ERROR</code>) Additional
            arguments may be passed and will be forwarded
            to <code>FORMAT</code> when generating the message string.
            By default, Hunchentoot sets this parameter to the name of
            a function that logs to a file.
            See <clix:ref>log-file</clix:ref> for further information.  Set
            this parameter to <code>NIL</code> in order to suppress
            message logging altogether.
          </p>
          <p>
            On Unix you can use <clix:arg>setuid</clix:arg>
            and <clix:arg>setgid</clix:arg> to change the UID and GID of the process
            directly after the server has been started.  (You might want to do
            this if you're using a privileged port like
            80.)  <clix:arg>setuid</clix:arg> and <clix:arg>setgid</clix:arg> can be
            integers (the actual IDs) or strings (for the user and group name
            respectively).
          </p>
          <p>
            If you want your server to use SSL, you must provide the pathname
            designator(s) <clix:arg>ssl-certificate-file</clix:arg> for the
            certificate file and optionally <clix:arg>ssl-privatekey-file</clix:arg>
            for the private key file, both files must be in PEM format.  If you
            only provide the value for <clix:arg>ssl-certificate-file</clix:arg> it
            is assumed that both the certificate and the private key are in one
            file.  If your private key needs a password you can provide it through
            the <clix:arg>ssl-privatekey-password</clix:arg> keyword argument.  If
            you <em>don't</em> use LispWorks, the private key must not be
            associated with a password, and the certificate and the private key
            must be in separate files.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="stop-server">
        <clix:lambda-list>
          server
        </clix:lambda-list>
        <clix:returns>
          |
        </clix:returns>
        <clix:description>
          Stops a server started
          with <clix:ref>START-SERVER</clix:ref>.  <clix:arg>server</clix:arg>
          must be an object as returned
          by <clix:ref>START-SERVER</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:special-variable name="*server*">
        <clix:description>
          During the execution of <a href="#handlers">dispatch functions
            and handlers</a> this variable is bound to the server object
          (as returned by <clix:ref>START-SERVER</clix:ref>) which
          processes the request.
        </clix:description>
      </clix:special-variable>

      <clix:reader name="server-local-port" class="server">
        <clix:returns>port</clix:returns>
        <clix:description>
          Return the port number that the <clix:arg>server</clix:arg> is
          listening on.
        </clix:description>
      </clix:reader>

      <clix:reader name="server-address" class="server">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> server</clix:lambda-list>
        <clix:returns>address</clix:returns>
        <clix:description>
          Returns the IP address that the <clix:arg>server</clix:arg> is
          listening on.
        </clix:description>
      </clix:reader>

      <clix:accessor name="server-dispatch-table" class="server">
        <clix:returns>dispatch-table</clix:returns>
        <clix:description>
          These methods can be used to get and set
          the <a href="#*dispatch-table*">dispatch table</a> of a
          Hunchentoot server object.  The value corresponds to
          the <clix:arg>dispatch-table</clix:arg> parameter
          of <clix:ref>START-SERVER</clix:ref> and can be changed at
          runtime.  It can be set to NIL which means that the server
          doesn't have its own dispatch table
          and <clix:ref>*DISPATCH-TABLE*</clix:ref> should be used
          instead.
        </clix:description>
      </clix:accessor>

      <clix:accessor name="server-name">
        <clix:lambda-list>server</clix:lambda-list>
        <clix:returns>name</clix:returns>
        <clix:description>
          These methods can be used to get and set the name of a server
          which must be a symbol.
        </clix:description>
      </clix:accessor>

      <clix:special-variable name="*default-connection-timeout*">
        <clix:description>
          The default value for the <clix:arg>connection-timeout</clix:arg> keyword
          argument to <clix:ref>START-SERVER</clix:ref>.  The initial value is 20
          (seconds).
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*cleanup-interval*">
        <clix:description>
          (Lispworks only)
          Should be <code>NIL</code> or a positive integer.  The system
          calls <clix:ref>*CLEANUP-FUNCTION*</clix:ref>
          whenever <clix:ref>*CLEANUP-INTERVAL*</clix:ref> new worker
          threads have been created unless the value
          is <code>NIL</code>. The initial value is 100.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*cleanup-function*">
        <clix:description>
          (Lispworks only)
          The function (with no arguments) which is called
          if <clix:ref>*CLEANUP-INTERVAL*</clix:ref> is
          not <code>NIL</code>.  The initial value is a function which
          calls
          <code>(<a href="http://www.lispworks.com/documentation/lw50/LWRM/html/lwref-166.htm">HCL</a>:<a href="http://www.lispworks.com/documentation/lw50/LWRM/html/lwref-212.htm">
              <code>MARK-AND-SWEEP</code> </a> 2)</code>.
          <p>
            On LispWorks this is necessary because each <em>worker</em>
            (which is created to handle an incoming http request and
            which dies afterwards unless the connection is persistent)
            is a Lisp process and LispWorks creates processes in
            generation 2.
          </p>
          <p>
            Note that you can also set this value to <code>NIL</code>
            and tune LispWork's GC yourself, using for
            example <a href="http://www.lispworks.com/documentation/lw50/LWRM/html/lwref-180.htm">
              <code>COLLECT-GENERATION-2</code></a>.
          </p>
        </clix:description>
      </clix:special-variable>
    </clix:subchapter>

    <clix:subchapter name="handlers" title="Handlers">
      <p>
        Hunchentoot handles each incoming request dynamically depending
        on the contents of a global <em>dispatch table</em>. The details
        can be found below. (See the file <code>test/test.lisp</code>
        for examples.)
      </p>

      <clix:special-variable name="*dispatch-table*">
        <clix:description>
          <p>
            This is a list
            of <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">function
              designators</a> for <em>dispatch functions</em> each of
            which should be a function of one argument which accepts
            a <clix:ref>REQUEST</clix:ref> object and, depending on this
            object, should either return a <em>handler</em> to handle
            the request or <code>NIL</code> which means that the next
            dispatcher will be queried. A <em>handler</em> is a
            designator for a function with no arguments which usually
            returns a string or an array of octets to be sent to the
            client as the body of the http reply. (Note that if you use
            symbols as function designators, you can redefine your
            handler functions without the need to change the dispatch
            functions.)  See <a href="#replies">the section about
              replies</a> for more about what handlers can do.
          </p>
          <p>
            The dispatchers in a dispatch table are tried in turn until
            one of them returns a handler. If this doesn't happen,
            Hunchentoot will return a 404 status code (Not Found) to the
            client.
          </p>
          <p>
            The initial value of <code>*DISPATCH-TABLE*</code> is a list
            which just contains the
            symbol <clix:ref>DEFAULT-DISPATCHER</clix:ref>.
          </p>
        </clix:description>
      </clix:special-variable>

      <clix:function name="default-dispatcher">
        <clix:lambda-list>request</clix:lambda-list>
        <clix:returns>handler</clix:returns>
        <clix:description>
          This is a function which will always unconditionally return
          the value of <clix:ref>*DEFAULT-HANDLER*</clix:ref>. It is
          intended to be the last element
          of <clix:ref>*DISPATCH-TABLE*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:special-variable name="*default-handler*">
        <clix:description>
          This variable holds the handler which is always returned
          by <clix:ref>DEFAULT-DISPATCHER</clix:ref>. The default value is
          a function which unconditonally shows a short Hunchentoot info
          page.
        </clix:description>
      </clix:special-variable>

      <clix:function name="create-prefix-dispatcher">
        <clix:lambda-list>prefix handler</clix:lambda-list>
        <clix:returns>dispatch-fn</clix:returns>
        <clix:description>
          A convenience function which will return a dispatcher that
          returns <clix:arg>handler</clix:arg> whenever the path part of
          the request URI starts with the
          string <clix:arg>prefix</clix:arg>.
        </clix:description>
      </clix:function>

      <clix:function name="create-regex-dispatcher">
        <clix:lambda-list>regex handler</clix:lambda-list>
        <clix:returns>dispatch-fn</clix:returns>
        <clix:description>
          A convenience function which will return a dispatcher that
          returns <clix:arg>handler</clix:arg> whenever the path part of
          the request URI matches
          the <a href="http://weitz.de/cl-ppcre/">CL-PPCRE</a> regular
          expression <clix:arg>regex</clix:arg> (which can be a string, an
          s-expression, or a scanner).
        </clix:description>
      </clix:function>

      <clix:function name="handle-static-file">
        <clix:lambda-list>path <clix:lkw>optional</clix:lkw> content-type</clix:lambda-list>
        <clix:returns>nil</clix:returns>
        <clix:description>
          Sends the file denoted by the pathname designator
          <clix:arg>path</clix:arg> with content type
          <clix:arg>content-type</clix:arg> to the client.  Sets the
          necessary handlers.  In particular the function employs
          <clix:ref>HANDLE-IF-MODIFIED-SINCE</clix:ref>.
          <p>
            If <clix:arg>content-type</clix:arg> is <code>NIL</code> the
            function tries to determine the correct content type from
            the file's suffix or falls back
            to <code>"application/octet-stream"</code> as a last resort.
          </p>
          <p>
            Note that this function
            calls <clix:ref>SEND-HEADERS</clix:ref> internally, so after
            you've called it, the headers are sent and the return value
            of your handler is ignored.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="create-static-file-dispatcher-and-handler">
        <clix:lambda-list>uri path <clix:lkw>optional</clix:lkw> content-type</clix:lambda-list>
        <clix:returns>dispatch-fn</clix:returns>
        <clix:description>
          A convenience function which will return a dispatcher that
          dispatches to a handler which emits the file denoted by the
          pathname designator <clix:arg>path</clix:arg> with content type
          <clix:arg>content-type</clix:arg> if
          the <clix:ref>SCRIPT-NAME</clix:ref> of the request matches the
          string <clix:arg>uri</clix:arg>.
          Uses <clix:ref>HANDLE-STATIC-FILE</clix:ref> internally.
          <p>
            If <clix:arg>content-type</clix:arg> is <code>NIL</code> the
            function tries to determine the correct content type from
            the file's suffix or falls back
            to <code>"application/octet-stream"</code> as a last resort.
            <clix:ref>*DEFAULT-CONTENT-TYPE*</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="create-folder-dispatcher-and-handler">
        <clix:lambda-list>uri-prefix base-path <clix:lkw>optional</clix:lkw> content-type</clix:lambda-list>
        <clix:returns>dispatch-fn</clix:returns>
        <clix:description>
          Creates and returns a dispatch function which will dispatch to
          a handler function which emits the file relative
          to <clix:arg>base-path</clix:arg> that is denoted by the URI of
          the request relative
          to <clix:arg>uri-prefix</clix:arg>.  <clix:arg>uri-prefix</clix:arg>
          must be a string ending with a
          slash, <clix:arg>base-path</clix:arg> must be a pathname
          designator for an existing directory.
          Uses <clix:ref>HANDLE-STATIC-FILE</clix:ref> internally.
          <p>
            If <clix:arg>content-type</clix:arg> is <em>not</em>
            <code>NIL</code>, it will be used as a the content type for
            all files in the folder.  Otherwise (which is the default)
            the content type of each file will be
            determined <a href="#handle-static-file">as usual</a>.
          </p>
        </clix:description>
      </clix:function>

      <clix:function generic="true" name="dispatch-request">
        <clix:lambda-list>dispatch-table</clix:lambda-list>
        <clix:returns>result</clix:returns>
        <clix:description>
          This is a generic function so users can customize its
          behaviour.  Look at the source code for details.
        </clix:description>
      </clix:function>

      <clix:function macro="true" name="define-easy-handler">
        <clix:lambda-list>description lambda-list [[declaration* | documentation]] form*</clix:lambda-list>
        <clix:description>
          Defines a handler as if
          by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defun.htm">
            <code>DEFUN</code></a> and optionally registers it with a
          URI so that it will be found
          by <clix:ref>DISPATCH-EASY-HANDLERS</clix:ref>.
          <p>
            <clix:arg>description</clix:arg> is either a
            symbol <clix:arg>name</clix:arg> or a list matching the
            <a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_de.htm">destructuring
              lambda list</a>
          </p>
          <pre>(name &amp;key uri server-names default-parameter-type default-request-type).</pre>
          <clix:arg>lambda-list</clix:arg> is a list the elements of which
          are either a symbol <clix:arg>var</clix:arg> or a list matching
          the destructuring lambda list
          <pre>(var &amp;key real-name parameter-type init-form request-type).</pre>
          The resulting handler will be a Lisp function with the
          name <clix:arg>name</clix:arg> and keyword parameters named by
          the <clix:arg>var</clix:arg> symbols.
          Each <clix:arg>var</clix:arg> will be bound to the value of the
          GET or POST parameter called <clix:arg>real-name</clix:arg> (a
          string) before the body of the function is executed.
          If <clix:arg>real-name</clix:arg> is not provided, it will be
          computed
          by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm#string-downcase">downcasing</a>
          the symbol name of <clix:arg>var</clix:arg>.
          <p>
            If <clix:arg>uri</clix:arg> (which is evaluated) is provided,
            then it must be a string or
            a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">function
              designator</a> for a unary function.  In this case, the
            handler will be returned
            by <clix:ref>DISPATCH-EASY-HANDLERS</clix:ref> ,
            if <clix:arg>uri</clix:arg> is a string and
            the <a href="#script-name">script name</a> of the current
            request is <clix:arg>uri</clix:arg>, or
            if <clix:arg>uri</clix:arg> designates a function and applying
            this function to
            the <a href="#*request*">current <code>REQUEST</code>
              object</a> returns a true value.
          </p>
          <p>
            <clix:arg>server-names</clix:arg> (which is evaluated) can be a
            list of symbols which means that the handler will only be
            returned by <clix:ref>DISPATCH-EASY-HANDLERS</clix:ref> in
            servers which have one of these names
            (see <clix:ref>SERVER-NAME</clix:ref>).  <clix:arg>server-names</clix:arg> can also be the
            symbol <code>T</code> which means that the handler will be
            returned by <clix:ref>DISPATCH-EASY-HANDLERS</clix:ref>
            in <em>every</em> server.
          </p>
          <p>
            Whether the GET or POST parameter (or both) will be taken into
            consideration, depends on <clix:arg>request-type</clix:arg>
            which can
            be <code>:GET</code>, <code>:POST</code>, <code>:BOTH</code>,
            or <code>NIL</code>.  In the last case, the value of
            <clix:arg>default-request-type</clix:arg> (the default of which
            is <code>:BOTH</code>) will be used.
          </p>
          <p>
            The value of <clix:arg>var</clix:arg> will usually be a string
            (unless it resulted from a <a href="#upload">file upload</a>
            in which case it won't be converted at all), but
            if <clix:arg>parameter-type</clix:arg> (which is evaluated) is
            provided, the string will be converted to another Lisp type by
            the following rules:
          </p>
          <p>
            If the corresponding GET or POST parameter wasn't provided by
            the client, <clix:arg>var</clix:arg>'s value will
            be <code>NIL</code>.  If <clix:arg>parameter-type</clix:arg>
            is <code>'STRING</code>,
            <clix:arg>var</clix:arg>'s value remains as is.
            If <clix:arg>parameter-type</clix:arg> is <code>'INTEGER</code>
            and the parameter string consists solely of decimal
            digits, <clix:arg>var</clix:arg>'s value will be the
            corresponding integer, otherwise <code>NIL</code>.
            If <clix:arg>parameter-type</clix:arg> is
            <code>'KEYWORD</code>, <clix:arg>var</clix:arg>'s value will be
            the keyword obtained
            by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_intern.htm">interning</a>
            the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_stg_up.htm#string-upcase">upcased</a>
            parameter string into
            the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/11_abc.htm">keyword
              package</a>.  If <clix:arg>parameter-type</clix:arg>
            is <code>'CHARACTER</code> and the parameter string is of
            length one, <clix:arg>var</clix:arg>'s value will be the single
            character of this string, otherwise <code>NIL</code>.
            If <clix:arg>parameter-type</clix:arg>
            is <code>'BOOLEAN</code>, <clix:arg>var</clix:arg>'s value will
            always be <code>T</code> (unless it is <code>NIL</code> by the
            first rule above, of course).
            If <clix:arg>parameter-type</clix:arg> is any other atom, it is
            supposed to be
            a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">function
              designator</a> for a unary function which will be called to
            convert the string to something else.
          </p>
          <p>
            Those were the rules for <em>simple</em> parameter types, but
            <clix:arg>parameter-type</clix:arg> can also be a list starting
            with one of the symbols
            <code>LIST</code>, <code>ARRAY</code>,
            or <code>HASH-TABLE</code>.  The second value of the list must
            always be a simple parameter type as in the last paragraph -
            we'll call it the <em>inner type</em> below.
          </p>
          <p>
            In the case of <code>'LIST</code>, all GET/POST parameters
            called <clix:arg>real-name</clix:arg> will be collected,
            converted to the inner type as by the rules above, and
            assembled into a list which will be the value of
            <clix:arg>var</clix:arg>.
          </p>
          <p>
            In the case of <code>'ARRAY</code>, all GET/POST parameters
            which have a name like the result of
          </p>
          <pre>(format nil "~A[~A]" real-name n)</pre>
          where <clix:arg>n</clix:arg> is a non-negative integer, will be
          assembled into an array where the <clix:arg>n</clix:arg>th element
          will be set accordingly, after conversion to the inner type.
          The array, which will become the value
          of <clix:arg>var</clix:arg>, will be big enough to hold all
          matching parameters, but not bigger.  Array elements not set as
          described above will be <code>NIL</code>.  Note
          that <code>VAR</code> will always be bound to an array, which
          may be empty, so it will never be <code>NIL</code>, even if no
          appropriate GET/POST parameters are found.
          <p>
            The full form of a <code>'HASH-TABLE</code> parameter type is
          </p>
          <pre>(hash-table inner-type key-type test-function)</pre>
          but <clix:arg>key-type</clix:arg>
          and <clix:arg>test-function</clix:arg> can be left out in which
          case they default to <code>'STRING</code>
          and <code>'EQUAL</code>, respectively.  For this parameter type,
          all GET/POST parameters which have a name like the result of
          <pre>(format nil "~A{~A}" real-name key)</pre>
          (where <clix:arg>key</clix:arg> is a string that doesn't contain
          curly brackets) will become the values (after conversion
          to <clix:arg>inner-type</clix:arg>) of a hash table with test
          function <clix:arg>test-function</clix:arg>
          where <clix:arg>key</clix:arg> (after conversion
          to <clix:arg>key-type</clix:arg>) will be the corresponding key.
          Note that <clix:arg>var</clix:arg> will always be bound to a hash
          table, which may be empty, so it will never be <code>NIL</code>,
          even if no appropriate GET/POST parameters are found.
          <p>
            To make matters even more complicated, the three compound
            parameter types also have an abbreviated form - just one of
            the symbols <code>LIST</code>, <code>ARRAY</code>,
            or <code>HASH-TABLE</code>.  In this case, the inner type will
            default to <code>'STRING</code>.
          </p>
          <p>
            If <clix:arg>parameter-type</clix:arg> is not provided
            or <code>NIL</code>, <clix:arg>default-parameter-type</clix:arg>
            (the default of which is <code>'STRING</code>) will be used
            instead.
          </p>
          <p>
            If the result of the computations above would be
            that <clix:arg>var</clix:arg> would be bound
            to <code>NIL</code>, then <clix:arg>init-form</clix:arg> (if
            provided) will be evaluated instead,
            and <clix:arg>var</clix:arg> will be bound to the result of this
            evaluation.
          </p>
          <p>
            Handlers built with this macro are constructed in such a way
            that the resulting Lisp function is useful even outside of
            Hunchentoot.  Specifically, all the parameter computations
            above will only happen if <clix:ref>*REQUEST*</clix:ref> is
            bound, i.e. if we're within a Hunchentoot request.
            Otherwise, <clix:arg>var</clix:arg> will always be bound to the
            result of evaluating <clix:arg>init-form</clix:arg> unless a
            corresponding keyword argument is provided.
          </p>
          <p>
            The <a href="#example">example code</a> that comes with
            Hunchentoot contains an example which demonstrates some of the
            features of <clix:ref>DEFINE-EASY-HANDLER</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="dispatch-easy-handlers">
        <clix:lambda-list>request</clix:lambda-list>
        <clix:returns>handler</clix:returns>
        <clix:description>
          This is a dispatcher which returns the appropriate handler
          defined with <clix:ref>DEFINE-EASY-HANDLER</clix:ref> , if there
          is one.  The newest handlers are checked
          first.  <clix:ref>DEFINE-EASY-HANDLER</clix:ref> makes sure that
          there's always only one handler per name and one per URI.
          URIs are compared
          by <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_equal.htm">
            <code>EQUAL</code></a>, so anonymous functions won't be
          recognized as being identical.
        </clix:description>
      </clix:function>
    </clix:subchapter>

    <clix:subchapter name="requests" title="Requests">

      When a request comes in, Hunchentoot creates
      a <code>REQUEST</code> object which is available to
      the <a href="#handlers">handler</a> via the special
      variable <clix:ref>*REQUEST*</clix:ref>. This object holds all the
      information available about the request and can be queried with
      the functions described in this chapter. Note that the internal
      structure of <code>REQUEST</code> objects should be considered
      opaque and may change in future releases of Hunchentoot.
      <p>
        In all of the functions below, the default value
        for <clix:arg>request</clix:arg> (which is either an optional or a
        keyword argument) is the value of <clix:ref>*REQUEST*</clix:ref> ,
        i.e. handlers will usually not need to provide this argument
        when calling the function.
      </p>
      <p>
        (Some of the function names in this section might seem a bit
        strange.  This is because they were initially chosen to be
        similar to environment variables in CGI scripts.)
      </p>

      <clix:class name="request">
        <clix:description>
          Objects of this class hold all the information about
          incoming requests and are used by Hunchentoot for the
          dispatch mechanism, amongst other things.  You should not
          mess with the slots of these objects directly, but you can
          subclass <clix:ref>REQUEST</clix:ref> in order to implement
          your own behaviour.  See for example
          the <clix:arg>request-class</clix:arg> keyword argument
          of <clix:ref>START-SERVER</clix:ref>, the
          function <clix:ref>DISPATCH-REQUEST</clix:ref>, and the
          variable <clix:ref>*REQUEST*</clix:ref>.
        </clix:description>
      </clix:class>

      <clix:special-variable name="*request*">
        <clix:description>
          Holds the current <clix:ref>REQUEST</clix:ref> object.
        </clix:description>
      </clix:special-variable>

      <clix:function name="host">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the incoming <code>Host</code> http
          header.  (This corresponds to the environment
          variable <code>HTTP_HOST</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="request-method">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>keyword</clix:returns>
        <clix:description>
          Returns the request method as a keyword, i.e. something
          like <code>:POST</code>.  (This corresponds to the environment
          variable <code>REQUEST_METHOD</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="request-uri">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the URI for <clix:arg>request</clix:arg>. Note that this
          not the full URI but only the part behind the scheme and
          authority components, so that if the user has
          typed <code>http://user:password@www.domain.com/xxx/frob.html?foo=bar</code>
          into his browser, this function will
          return <code>"/xxx/frob.html?foo=bar"</code>.  (This
          corresponds to the environment
          variable <code>REQUEST_URI</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="script-name">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the file name (or path) component of the URI
          for <clix:arg>request</clix:arg>, i.e. the part of the string
          returned by <clix:ref>REQUEST-URI</clix:ref> in front of the
          first question mark (if any).  (This corresponds to the
          environment variable <code>SCRIPT_NAME</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="query-string">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the query component of the URI
          for <clix:arg>request</clix:arg>, i.e. the part of the string
          returned by <clix:ref>REQUEST-URI</clix:ref> behind the first
          question mark (if any).  (This corresponds to the environment
          variable <code>QUERY_STRING</code> in CGI scripts.) See
          also <clix:ref>GET-PARAMETER</clix:ref>
          and <clix:ref>GET-PARAMETERS</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="get-parameter">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the GET parameter (as provided via the
          request URI) named by the string <clix:arg>name</clix:arg> as a
          string (or <code>NIL</code> if there ain't no GET parameter
          with this name). Note that only the first value will be
          returned if the client provided more than one GET parameter
          with the name <clix:arg>name</clix:arg>. See
          also <clix:ref>GET-PARAMETERS</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="get-parameters">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>alist</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all GET parameters (as provided via the request
          URI). The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the parameter's name while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is its value (as a string). The elements of this list are in
          the same order as they were within the request URI. See
          also <clix:ref>GET-PARAMETER</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="post-parameter">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the POST parameter (as provided in the
          request's body) named by the
          string <clix:arg>name</clix:arg>. Note that only the first value
          will be returned if the client provided more than one POST
          parameter with the name <clix:arg>name</clix:arg>.  This value
          will usually be a string (or <code>NIL</code> if there ain't
          no POST parameter with this name). If, however, the browser
          sent a <a class="none" name="upload">file</a> through
          a <a href="http://www.faqs.org/rfcs/rfc2388.html">
            <code>multipart/form-data</code>
          </a> form, the value of this function is a three-element list
          <pre>(path file-name content-type)</pre>
          where <clix:arg>path</clix:arg> is a pathname denoting the place
          were the uploaded file was
          stored, <clix:arg>file-name</clix:arg> (a string) is the file
          name sent by the browser, and <clix:arg>content-type</clix:arg>
          (also a string) is the content type sent by the browser. The
          file denoted by <clix:arg>path</clix:arg> will be deleted after
          the request has been handled - you have to move or copy it
          somewhere else if you want to keep it.
          <p>
            POST parameters will only be computed if the content type of
            the request body was <code>multipart/form-data</code>
            or <code>application/x-www-form-urlencoded</code>.  Although
            this function is called <code>POST-PARAMETER</code>, you can
            instruct Hunchentoot to compute these parameters for other
            request methods by
            setting <clix:ref>*METHODS-FOR-POST-PARAMETERS*</clix:ref>.
          </p>
          <p>
            See also <clix:ref>POST-PARAMETERS</clix:ref>
            and <clix:ref>*TMP-DIRECTORY*</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="post-parameters">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>alist</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all POST parameters (as provided via the request's
          body). The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the parameter's name while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is its value. The elements of this list are in the same order
          as they were within the request's body.
          <p>
            See also <clix:ref>POST-PARAMETER</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:special-variable name="*methods-for-post-parameters*">
        <clix:description>
          A list of the request method types (as keywords) for which
          Hunchentoot will try to
          compute <a href="#post-parameter">"POST" parameters</a>.  The
          default is the list with the single
          element <code>:POST</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*file-upload-hook*">
        <clix:description>
          If this is not <code>NIL</code>, it should be
          a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">designator</a>
          for a unary function which will be called with a pathname for
          each file which is <a href="#upload">uploaded</a> to
          Hunchentoot.  The pathname denotes the temporary file to which
          the uploaded file is written.  The hook is called
          directly <em>before</em> the file is created.  At this
          point, <clix:ref>*REQUEST*</clix:ref> is already bound to the
          current <code>REQUEST</code> object, but obviously you can't
          access the post parameters yet.
        </clix:description>
      </clix:special-variable>

      <clix:function name="raw-post-data">
        <clix:lambda-list>
          <clix:lkw>key</clix:lkw>
          request external-format force-text force-binary want-stream
        </clix:lambda-list>
        <clix:returns>raw-body-or-stream</clix:returns>
        <clix:description>
          Returns the content sent by the client in the request body if
          there was any (unless the content type
          was <code>multipart/form-data</code> in which
          case <code>NIL</code> is returned).  By default, the result is
          a string if the type of the <code>Content-Type</code>
          <a href="http://www.faqs.org/rfcs/rfc1590.html">media type</a>
          is <code>"text"</code>, and a vector of octets otherwise.  In
          the case of a string, the external format to be used to decode
          the content will be determined from the <code>charset</code>
          parameter sent by the client (or
          otherwise <clix:ref>*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</clix:ref>
          will be used).
          <p>
            You can also provide an external format explicitly (through
            <clix:arg>external-format</clix:arg>) in which case the result
            will unconditionally be a string.  Likewise, you can provide
            a true value for <clix:arg>force-text</clix:arg> which will
            force Hunchentoot to act as if the type of the media type
            had been <code>"text"</code>
            (with <clix:arg>external-format</clix:arg> taking precedence
            if provided).  Or you can provide a true value
            for <clix:arg>force-binary</clix:arg> which means that you
            want a vector of octets at any rate.  (If both
            <clix:arg>force-text</clix:arg>
            and <clix:arg>force-binary</clix:arg> are true, an error will
            be signaled.)
          </p>
          <p>
            If, however, you provide a true value
            for <clix:arg>want-stream</clix:arg>, the other parameters are
            ignored and you'll get the content (flexi) stream to read
            from it yourself.  It is then your responsibility to read
            the correct amount of data, because otherwise you won't be
            able to return a response to the client.  The stream will
            have
            its <a href="http://weitz.de/flexi-streams/#flexi-streams">octet
              position</a> set to <code>0</code>.  If the client provided
            a <code>Content-Length</code> header, the stream will also
            have a
            corresponding <a href="http://weitz.de/flexi-streams/#flexi-streams">bound</a>,
            so no matter whether the client used chunked encoding or
            not, you can always read until EOF.
          </p>
          <p>
            If the content type of the request
            was <code>multipart/form-data</code>
            or <code>application/x-www-form-urlencoded</code>, the
            content has been read by Hunchentoot already and you can't
            read from the stream anymore.
          </p>
          <p>
            You can call <clix:ref>RAW-POST-DATA</clix:ref> more than once
            per request, but you can't mix calls which have different
            values for <clix:arg>want-stream</clix:arg>.
          </p>
          <p>
            Note that this function is slightly misnamed because a
            client can send content even if the request method is not
            POST.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="parameter">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the GET or POST parameter named by the
          string <clix:arg>name</clix:arg> as a string
          (or <code>NIL</code> if there ain't no parameter with this
          name). If both a GET and a POST parameter with the
          name <clix:arg>name</clix:arg> exist, the GET parameter will be
          returned. See also <clix:ref>GET-PARAMETER</clix:ref>
          and <clix:ref>POST-PARAMETER</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="header-in">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the incoming header named by the
          keyword <clix:arg>name</clix:arg> as a string
          (or <code>NIL</code> if there ain't no header with this
          name).
          <p>
            For backwards compatibility, <clix:arg>name</clix:arg> can
            also be a string which is matched case-insensitively.  See
            also <clix:ref>HEADERS-IN</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="headers-in">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>alist</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all incoming
          headers. The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the headers's name (a Lisp
          keyword) while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is its value (as a string). There's no guarantee about the
          order of this list. See also <clix:ref>HEADER-IN</clix:ref> and
          the remark about incoming headers there.
        </clix:description>
      </clix:function>

      <clix:function name="authorization">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>user, password</clix:returns>
        <clix:description>
          Returns as two values the user and password (if any) from the
          incoming <code>Authorization</code> http header.
          Returns <code>NIL</code> if there is no such header.
          <p>
            If you want to use non-ASCII characters here, look at
            Christian Haselbach's <a href="http://mr-co.de/projects/cl-rfc2047/">CL-RFC2047</a>
            library.  See <a href="http://common-lisp.net/pipermail/tbnl-devel/2008-May/001932.html">here</a>
            for a code example.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="remote-addr">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the IP address (as a string) of the client which sent
          the request.  (This corresponds to the environment
          variable <code>REMOTE_ADDR</code> in CGI scripts.) See
          also <clix:ref>REAL-REMOTE-ADDR</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="remote-port">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>number</clix:returns>
        <clix:description>
          Returns the IP port (as a number) of the client which sent the
          request.
        </clix:description>
      </clix:function>

      <clix:function name="real-remote-addr">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string{, list}</clix:returns>
        <clix:description>
          Returns the value of the
          incoming <a href="http://en.wikipedia.org/wiki/XFF">
            <code>X-Forwarded-For</code></a> http header as the second
          value in the form of a list of IP addresses and the first
          element of this list as the first value if this header
          exists. Otherwise returns the value
          of <clix:ref>REMOTE-ADDR</clix:ref> as the only value.
        </clix:description>
      </clix:function>

      <clix:function name="server-address">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> server</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the IP address (as a string) where the request came in.  (This
          roughly corresponds to the environment variable <code>SERVER_ADDR</code>
          in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="server-port">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> server</clix:lambda-list>
        <clix:returns>number</clix:returns>
        <clix:description>
          Returns the IP port (as a number) of the current
          server.  <clix:arg>server</clix:arg> defaults
          to <clix:ref>*SERVER*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="server-protocol">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>keyword</clix:returns>
        <clix:description>
          Returns the version of the http protocol which is used by the
          client as a Lisp keyword - this is usually
          either <code>:HTTP/1.0</code> or <code>:HTTP/1.1</code>.
          (This corresponds to the environment
          variable <code>SERVER_PROTOCOL</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="user-agent">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the incoming <code>User-Agent</code> http
          header.  (This corresponds to the environment
          variable <code>HTTP_USER_AGENT</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="referer">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the incoming <code>Referer</code> (sic!)
          http header.  (This corresponds to the environment
          variable <code>HTTP_REFERER</code> in CGI scripts.)
        </clix:description>
      </clix:function>

      <clix:function name="cookie-in">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns the value of the incoming cookie named by the
          string <clix:arg>name</clix:arg> (or <code>NIL</code> if there
          ain't no cookie with this name). See
          also <clix:ref>COOKIES-IN</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="cookies-in">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all incoming
          cookies. The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the cookie's name while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is the cookie's value. See also <clix:ref>COOKIE-IN</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:accessor name="aux-request-value">
        <clix:lambda-list>symbol <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>value, present-p</clix:returns>
        <clix:description>
          This accessor can be used to associate arbitrary data with the
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#symbol">symbol</a>
          <clix:arg>symbol</clix:arg> in the <code>REQUEST</code>
          object <clix:arg>request</clix:arg>.
          <clix:arg>present-p</clix:arg> is <em>true</em> if such data was
          found, otherwise <code>NIL</code>.
        </clix:description>
      </clix:accessor>

      <clix:function name="delete-aux-request-value">
        <clix:lambda-list>symbol <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Completely removes any data associated with
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#symbol">symbol</a>
          <clix:arg>symbol</clix:arg> from the <code>REQUEST</code>
          object <clix:arg>request</clix:arg>. Note that this is different
          from using <clix:ref>AUX-REQUEST-VALUE</clix:ref> to set the
          data to <code>NIL</code>.
        </clix:description>
      </clix:function>

      <clix:function name="recompute-request-parameters">
        <clix:lambda-list><clix:lkw>key</clix:lkw> request external-format</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Recomputes the GET and POST parameters for
          the <code>REQUEST</code> object
          <clix:arg>request</clix:arg>.  This only makes sense if you've
          changed the external format and with POST parameters it will
          only work if the request body was sent with
          the <code>application/x-www-form-urlencoded</code> content
          type.
          <p>
            The default value for
            <clix:arg>external-format</clix:arg>
            is <clix:ref>*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</clix:ref>.
            See <code>test/test.lisp</code> for an example.
          </p>
        </clix:description>
      </clix:function>
    </clix:subchapter>

    <clix:subchapter name="replies" title="Replies">

      It is the responsibility of a <a href="#handlers">handler</a>
      function to prepare the reply for the client. This is done by

      <ul>
        <li>returning a string or an array of octets which will be the reply's body and</li>
        <li>manipulating a <code>REPLY</code> object which will be described in this section.</li>
      </ul>

      For each request there's one <code>REPLY</code> object which is
      accessible to the handler via the special
      variable <a href="#*reply*">*REPLY*</a>. This object holds all the
      information available about the reply and can be accessed with the
      functions described in this chapter. Note that the internal
      structure of <code>REPLY</code> objects should be considered
      opaque and may change in future releases of Hunchentoot.
      <p>
        In all of the functions below, the default value
        for the optional argument <clix:arg>reply</clix:arg> is the value of <a href="#*reply*">*REPLY*</a>,
        i.e. handlers will usually not need to provide this argument when
        calling the function.
      </p>
      <p>
        While Hunchentoot's preferred way of sending data to the client is the
        one described above (i.e. the handler returns the whole payload as a
        string or an array of octets) you can, if you really need to (for
        example for large content bodies), get a stream you can write to
        directly.  This is achieved by first setting
        up <clix:ref>*REPLY*</clix:ref> and then
        calling <clix:ref>SEND-HEADERS</clix:ref>.  Note
        that in this case the usual <a href="#log">error handling</a> is
        disabled.  See the file <code>test/test.lisp</code> for an example.
      </p>

      <clix:special-variable name="*reply*">
        <clix:description>
          Holds the current <code>REPLY</code> object.
        </clix:description>
      </clix:special-variable>

      <clix:accessor name="header-out">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          <code>HEADER-OUT</code> returns the outgoing http header named
          by the keyword <clix:arg>name</clix:arg> if there is one,
          otherwise <code>NIL</code>. <code>SETF</code>
          of <code>HEADER-OUT</code> changes the current value of the header
          named <clix:arg>name</clix:arg>. If no header
          named <clix:arg>name</clix:arg> exists it is created.  For backwards
          compatibility, <clix:arg>name</clix:arg> can also be a string in which
          case the association between a header and its name is
          case-insensitive.
          <p>
            Note that the header <code>Set-Cookie</code> cannot be
            queried by <code>HEADER-OUT</code> and <em>must not</em>
            be set by <code>SETF</code> of <code>HEADER-OUT</code>.
            Also, there are a couple of "technical" headers
            like <code>Connection</code>
            or <code>Transfer-Encoding</code> that you're not supposed
            to set yourself.  If in doubt, consult the source code or
            ask on the <a href="#mail">mailing list</a>.
          </p>
          <p>
            See
            also <clix:ref>HEADERS-OUT</clix:ref>, <clix:ref>CONTENT-TYPE</clix:ref>
            , <clix:ref>CONTENT-LENGTH</clix:ref>, <clix:ref>COOKIES-OUT</clix:ref>,
            and <clix:ref>COOKIE-OUT</clix:ref>.
          </p>
        </clix:description>
      </clix:accessor>

      <clix:function name="headers-out">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>alist</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all outgoing http parameters (except
          for <code>Set-Cookie</code>). The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the headers's name while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is its value. This alist should not be manipulated directly,
          use <code>SETF</code> of <clix:ref>HEADER-OUT</clix:ref>
          instead.  The <clix:arg>reply</clix:arg> argument defaults
          to <clix:ref>*REPLY*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="cookie-out">
        <clix:lambda-list>name <clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>cookie</clix:returns>
        <clix:description>
          Returns the outgoing cookie named by the
          string <clix:arg>name</clix:arg> (or <code>NIL</code> if there
          ain't no cookie with this name). See
          also <clix:ref>COOKIES-OUT</clix:ref> and <a href="#cookies">the
            section about cookies</a>.
        </clix:description>
      </clix:function>

      <clix:function name="cookies-out">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>alist</clix:returns>
        <clix:description>
          Returns
          an <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#alist">alist</a>
          of all outgoing
          cookies. The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#car">car</a>
          of each element of this list is the cookie's name while
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#cdr">cdr</a>
          is the cookie itself. See also <clix:ref>COOKIE-OUT</clix:ref>
          and <a href="#cookies">the section about cookies</a>.
        </clix:description>
      </clix:function>

      <clix:accessor name="return-code">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>number</clix:returns>
        <clix:description>
          <code>RETURN-CODE</code> returns the http return code of the
          reply, <code>SETF</code> of <code>RETURN-CODE</code> changes
          it. The return code of each <code>REPLY</code> object is
          initially set to <clix:ref>+HTTP-OK+</clix:ref>.
        </clix:description>
      </clix:accessor>

      <clix:accessor name="content-type">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          <code>CONTENT-TYPE</code> returns the
          outgoing <code>Content-Type</code> http
          header. <code>SETF</code> of <code>CONTENT-TYPE</code> changes
          the current value of this header. The content type of
          each <code>REPLY</code> object is initially set to the value
          of <clix:ref>*DEFAULT-CONTENT-TYPE*</clix:ref>.
        </clix:description>
      </clix:accessor>

      <clix:accessor name="content-length">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>length</clix:returns>
        <clix:description>
          <code>CONTENT-LENGTH</code> returns the outgoing
          <code>Content-Length</code> http header. <code>SETF</code> of
          <code>CONTENT-LENGTH</code> changes the current value of this
          header. The content length of each <code>REPLY</code> object
          is initially set to <code>NIL</code>.  If you leave it like
          that, Hunchentoot will automatically try to compute the
          correct value
          using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_length.htm">
            <code>LENGTH</code>
          </a>.  If you set the value yourself, you <em>must</em> make
          sure that it's the correct length of the body
          in <em>octets</em> (not in characters).  In this case,
          Hunchentoot will use the value as is which can lead to
          erroneous behaviour if it is wrong - so, use at your own risk.
          <p>
            Note that setting this value explicitly doesn't mix well
            with <a href="#*rewrite-for-session-urls*">URL
              rewriting</a>.
          </p>
        </clix:description>
      </clix:accessor>

      <clix:function name="send-headers">
        <clix:returns>stream</clix:returns>
        <clix:description>
          Sends the initial status line and all headers as determined
          by the <code>REPLY</code>
          object <clix:ref>*REPLY*</clix:ref>.  Returns
          a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_b.htm#binary">binary</a>
          to which the body of the reply can be written.  Once this
          function has been called, further changes
          to <clix:ref>*REPLY*</clix:ref> don't have any effect.
          Also,
          <a href="#log">automatic handling of errors</a> (i.e. sending
          the corresponding status code to the browser, etc.) is turned
          off for this request.  Likewise, functions
          like <clix:ref>REDIRECT</clix:ref> or throwing
          to <clix:ref>HANDLER-DONE</clix:ref> won't have the desired
          effect once the headers are sent.
          <p>
            If your handlers return the full body as a string or as an
            array of octets, you should <em>not</em> call this function.
            If a handler calls <clix:ref>SEND-HEADERS</clix:ref> , its
            return value is ignored.
          </p>
          <p>
            See also <clix:ref>REPLY-EXTERNAL-FORMAT</clix:ref>.
          </p>
        </clix:description>
      </clix:function>

      <clix:accessor name="reply-external-format">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>external-format</clix:returns>
        <clix:description>
          Gets and sets the external format of the <code>REPLY</code>
          object <clix:arg>reply</clix:arg>.  This external format is used
          when character content is written to the client after the
          headers have been sent.
          <p>
            The initial value for each request is the value
            of <clix:ref>*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</clix:ref>.
          </p>
        </clix:description>
      </clix:accessor>

      <clix:constants>
        <clix:listed-constant name="+http-continue+"/>
        <clix:listed-constant name="+http-switching-protocols+"/>
        <clix:listed-constant name="+http-ok+"/>
        <clix:listed-constant name="+http-created+"/>
        <clix:listed-constant name="+http-accepted+"/>
        <clix:listed-constant name="+http-non-authoritative-information+"/>
        <clix:listed-constant name="+http-no-content+"/>
        <clix:listed-constant name="+http-reset-content+"/>
        <clix:listed-constant name="+http-partial-content+"/>
        <clix:listed-constant name="+http-multi-status+"/>
        <clix:listed-constant name="+http-multiple-choices+"/>
        <clix:listed-constant name="+http-moved-permanently+"/>
        <clix:listed-constant name="+http-moved-temporarily+"/>
        <clix:listed-constant name="+http-see-other+"/>
        <clix:listed-constant name="+http-not-modified+"/>
        <clix:listed-constant name="+http-use-proxy+"/>
        <clix:listed-constant name="+http-temporary-redirect+"/>
        <clix:listed-constant name="+http-bad-request+"/>
        <clix:listed-constant name="+http-authorization-required+"/>
        <clix:listed-constant name="+http-payment-required+"/>
        <clix:listed-constant name="+http-forbidden+"/>
        <clix:listed-constant name="+http-not-found+"/>
        <clix:listed-constant name="+http-method-not-allowed+"/>
        <clix:listed-constant name="+http-not-acceptable+"/>
        <clix:listed-constant name="+http-proxy-authentication-required+"/>
        <clix:listed-constant name="+http-request-time-out+"/>
        <clix:listed-constant name="+http-conflict+"/>
        <clix:listed-constant name="+http-gone+"/>
        <clix:listed-constant name="+http-length-required+"/>
        <clix:listed-constant name="+http-precondition-failed+"/>
        <clix:listed-constant name="+http-request-entity-too-large+"/>
        <clix:listed-constant name="+http-request-uri-too-large+"/>
        <clix:listed-constant name="+http-unsupported-media-type+"/>
        <clix:listed-constant name="+http-requested-range-not-satisfiable+"/>
        <clix:listed-constant name="+http-expectation-failed+"/>
        <clix:listed-constant name="+http-failed-dependency+"/>
        <clix:listed-constant name="+http-internal-server-error+"/>
        <clix:listed-constant name="+http-not-implemented+"/>
        <clix:listed-constant name="+http-bad-gateway+"/>
        <clix:listed-constant name="+http-service-unavailable+"/>
        <clix:listed-constant name="+http-gateway-time-out+"/>
        <clix:listed-constant name="+http-version-not-supported+"/>
        <clix:description>
          The values of these constants are 100, 101, 200, 201, 202,
          203, 204, 205, 206, 207, 300, 301, 302, 303, 304, 305, 307,
          400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411,
          412, 413, 414, 415, 416, 417, 424, 500, 501, 502, 503, 504,
          and 505. See <clix:ref>RETURN-CODE</clix:ref>.
        </clix:description>
      </clix:constants>

      <clix:special-variable name="*default-content-type*">
        <clix:description>
          The value of this variable is used to initialize the content
          type of each <code>REPLY</code> object. Its initial value
          is <code>"text/html;
            charset=iso-8859-1"</code>. See <clix:ref>CONTENT-TYPE</clix:ref>.
        </clix:description>
      </clix:special-variable>
    </clix:subchapter>

    <clix:subchapter name="cookies" title="Cookies">

      Outgoing cookies are stored in the request's <code>REPLY</code>
      object (see <clix:ref>COOKIE-OUT</clix:ref>
      and <clix:ref>COOKIES-OUT</clix:ref>). They are CLOS objects
      defined like this:

      <pre>(defclass cookie ()
  ((name :initarg :name
         :reader <a class="noborder" name="cookie-name">cookie-name</a>
         :type string
         :documentation "The name of the cookie - a string.")
   (value :initarg :value
          :accessor <a class="noborder" name="cookie-value">cookie-value</a>
          :initform ""
          :documentation "The value of the cookie. Will be URL-encoded when sent to the browser.")
   (expires :initarg :expires
            :initform nil
            :accessor <a class="noborder" name="cookie-expires">cookie-expires</a>
            :documentation "The time (a universal time) when the cookie expires (or NIL).")
   (path :initarg :path
         :initform nil
         :accessor <a class="noborder" name="cookie-path">cookie-path</a>
         :documentation "The path this cookie is valid for (or NIL).")
   (domain :initarg :domain
           :initform nil
           :accessor <a class="noborder" name="cookie-domain">cookie-domain</a>
           :documentation "The domain this cookie is valid for (or NIL).")
   (secure :initarg :secure
           :initform nil
           :accessor <a class="noborder" name="cookie-secure">cookie-secure</a>
           :documentation "A generalized boolean denoting whether this is a secure cookie.")
   (http-only :initarg :http-only
              :initform nil
              :accessor <a class="noborder" name="cookie-http-only">cookie-http-only</a>
              :documentation "A generalized boolean denoting whether this is a <a href="http://msdn2.microsoft.com/en-us/library/ms533046.aspx">HttpOnly</a> cookie.")))</pre>

      The <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_r.htm#reader">reader</a>
      <clix:ref>COOKIE-NAME</clix:ref> and
      the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_a.htm#accessor">accessors</a>
      <clix:ref>COOKIE-VALUE</clix:ref>, <clix:ref>COOKIE-EXPIRES</clix:ref>,
      <clix:ref>COOKIE-PATH</clix:ref>, <clix:ref>COOKIE-DOMAIN</clix:ref>, <clix:ref>COOKIE-SECURE</clix:ref>,
      and <clix:ref>COOKIE-HTTP-ONLY</clix:ref> are all exported from
      the <code>HUNCHENTOOT</code> package.

      <clix:function name="set-cookie">
        <clix:lambda-list>
          name <clix:lkw>key</clix:lkw> value expires path
          domain secure http-only reply
        </clix:lambda-list>
        <clix:returns>cookie</clix:returns>
        <clix:description>
          Creates a <code>COOKIE</code> object from the parameters
          provided to this function and adds it to the outgoing cookies
          of the <a href="#replies"><code>REPLY</code> object</a>
          <clix:arg>reply</clix:arg>. If a cookie with the same name
          (case-sensitive) already exists, it is replaced. The default
          for <clix:arg>reply</clix:arg>
          is <clix:ref>*REPLY*</clix:ref>. The default
          for <clix:arg>value</clix:arg> is the empty string.
        </clix:description>
      </clix:function>

      <clix:function name="set-cookie*">
        <clix:lambda-list>cookie <clix:lkw>optional</clix:lkw> reply</clix:lambda-list>
        <clix:returns>cookie</clix:returns>
        <clix:description>
          Adds the <code>COOKIE</code> object <clix:arg>cookie</clix:arg>
          to the outgoing cookies of
          the <a href="#replies"><code>REPLY</code> object</a>
          <clix:arg>reply</clix:arg>. If a cookie with the same name
          (case-sensitive) already exists, it is replaced. The default
          for <clix:arg>reply</clix:arg> is <clix:ref>*REPLY*</clix:ref>.
        </clix:description>
      </clix:function>
    </clix:subchapter>

    <clix:subchapter name="sessions" title="Sessions">

      Hunchentoot supports <em>sessions</em>: Once a Hunchentoot page
      has called <clix:ref>START-SESSION</clix:ref> , Hunchentoot uses
      either cookies or (if the client doesn't send the cookies
      back) <a href="#*rewrite-for-session-urls*">rewrites URLs</a> to
      keep track of this client, i.e. to provide a kind of 'state' for
      the stateless http protocol. The session associated with the
      client is an opaque CLOS object which can be used to store
      arbitrary data between requests.
      <p>
        Hunchentoot makes some reasonable effort to prevent
        eavesdroppers from hijacking sessions (see below), but this
        should not be considered really secure. Don't store sensitive
        data in sessions and rely solely on the session mechanism as a
        safeguard against malicious users who want to get at this data!
      </p>
      <p>
        For each request there's one <code>SESSION</code> object which
        is accessible to the handler via the special
        variable <clix:ref>*SESSION*</clix:ref>. This object holds all the
        information available about the session and can be accessed with
        the functions described in this chapter. Note that the internal
        structure of <code>SESSION</code> objects should be considered
        opaque and may change in future releases of Hunchentoot.
      </p>
      <p>
        Sessions are automatically verified for validity and age when
        the <a href="#requests"><code>REQUEST</code> object</a> is
        instantiated, i.e. if <clix:ref>*SESSION*</clix:ref> is
        not <code>NIL</code> then this session is valid (as far as
        Hunchentoot is concerned) and not too old.  Old sessions
        are <a href="#session-gc">automatically removed</a>.
      </p>

      <clix:special-variable name="*session*">
        <clix:description>
          Holds the current <code>SESSION</code> object (if any) or <code>NIL</code>.
        </clix:description>
      </clix:special-variable>

      <clix:function name="start-session">
        <clix:returns>session</clix:returns>
        <clix:description>
          Returns <clix:ref>*SESSION*</clix:ref> if it
          isn't <code>NIL</code>, otherwise creates a
          new <code>SESSION</code> object and returns it.
        </clix:description>
      </clix:function>

      <clix:accessor name="session-value">
        <clix:lambda-list>symbol <clix:lkw>optional</clix:lkw> session</clix:lambda-list>
        <clix:returns>value, present-p</clix:returns>
        <clix:description>
          This accessor can be used to associate arbitrary data with the
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#symbol">symbol</a>
          <clix:arg>symbol</clix:arg> in the <code>SESSION</code>
          object <clix:arg>session</clix:arg>.
          <clix:arg>present-p</clix:arg> is <em>true</em> if such data was
          found, otherwise <code>NIL</code>. The default value
          for <clix:arg>session</clix:arg>
          is <clix:ref>*SESSION*</clix:ref>.
          <p>
            If <code>SETF</code> of <code>SESSION-VALUE</code> is called
            with <clix:arg>session</clix:arg> being <code>NIL</code> then
            a session is automatically instantiated
            with <clix:ref>START-SESSION</clix:ref>.
          </p>
        </clix:description>
      </clix:accessor>

      <clix:function name="delete-session-value">
        <clix:lambda-list>symbol <clix:lkw>optional</clix:lkw> session</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Completely removes any data associated with
          the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_s.htm#symbol">symbol</a>
          <clix:arg>symbol</clix:arg> from the <code>SESSION</code>
          object <clix:arg>session</clix:arg>. Note that this is different
          from using <clix:ref>SESSION-VALUE</clix:ref> to set the data
          to <code>NIL</code>.  The default value
          for <clix:arg>session</clix:arg>
          is <clix:ref>*SESSION*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="remove-session">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Completely removes the session <clix:arg>session</clix:arg> from
          Hunchentoot's internal session database.  See
          also <clix:ref>*SESSION-REMOVAL-HOOK*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="reset-sessions">
        <clix:returns>|</clix:returns>
        <clix:description>
          This function unconditionally invalidates and
          destroys <em>all</em> sessions immediately.
        </clix:description>
      </clix:function>

      <clix:function name="session-cookie-value">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> session</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns a unique string that's associated with
          the <code>SESSION</code>
          object <clix:arg>session</clix:arg>. This string is sent to the
          browser as a cookie value or as a GET parameter.
        </clix:description>
      </clix:function>

      <clix:function name="session-counter">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>count</clix:returns>
        <clix:description>
          Returns the number of times (requests)
          the <code>SESSION</code> object <clix:arg>session</clix:arg> has
          been used.
        </clix:description>
      </clix:function>

      <clix:accessor name="session-max-time">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>seconds</clix:returns>
        <clix:description>
          This gets or sets the maximum time (in seconds)
          the <code>SESSION</code> object <clix:arg>session</clix:arg>
          should be valid before it's invalidated: If a request
          associated with this session comes in and the last request for
          the same session was more than <clix:arg>seconds</clix:arg>
          seconds ago than the session is deleted and a new one is
          started for this client.  The default value is determined
          by <clix:ref>*SESSION-MAX-TIME*</clix:ref>.
        </clix:description>
      </clix:accessor>

      <clix:function name="session-remote-addr">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>address</clix:returns>
        <clix:description>
          Returns the 'real' remote address
          (see <clix:ref>REAL-REMOTE-ADDR</clix:ref>) of the client for
          which the <code>SESSION</code>
          object <clix:arg>session</clix:arg> was initiated.
        </clix:description>
      </clix:function>

      <clix:function name="session-user-agent">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>address</clix:returns>
        <clix:description>
          Returns the 'User-Agent' http header
          (see <clix:ref>USER-AGENT</clix:ref>) of the client for which
          the <code>SESSION</code> object <clix:arg>session</clix:arg> was
          initiated.
        </clix:description>
      </clix:function>

      <clix:special-variable name="*use-remote-addr-for-sessions*">
        <clix:description>
          If this value is <em>true</em> (the default
          is <code>NIL</code>) then the 'real' remote address
          (see <clix:ref>REAL-REMOTE-ADDR</clix:ref>) of the client will
          be encoded into the session identifier, i.e. if this value
          changes on the client side, the session will automatically be
          invalidated.
          <p>
            Note that this is not secure, because it's obviously not
            very hard to fake an <code>X_FORWARDED_FOR</code> header. On
            the other hand, relying on the remote address
            (see <clix:ref>REMOTE-ADDR</clix:ref>) of the client isn't an
            ideal solution either, because some of your users may
            connect through http proxies and the proxy they use may
            change during the session. But then again, some proxies
            don't send <code>X_FORWARDED_FOR</code> headers
            anyway. Sigh...
          </p>
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*use-user-agent-for-sessions*">
        <clix:description>
          If this value is <em>true</em> (which is the default) then the
          'User-Agent' http header (see <clix:ref>USER-AGENT</clix:ref>)
          of the client will be encoded into the session identifier,
          i.e. if this value changes on the client side the session will
          automatically be invalidated.
          <p>
            While this is intended to make the life of malicious users
            harder, it might affect legitimate users as well: I've seen
            this http header change with certain browsers when the Java
            plug-in or the Google toolbar was used.
          </p>
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*rewrite-for-session-urls*">
        <clix:description>
          If this value is <em>true</em> (which is the default) then
          content bodies sent by Hunchentoot will be rewritten
          (using <a href="http://weitz.de/url-rewrite/">URL-REWRITE</a>)
          such that GET parameters for session handling are appended to
          all relevant URLs. This only happens, though, if the body's
          content type (see <clix:ref>CONTENT-TYPE</clix:ref>) starts
          with one of the strings
          in <clix:ref>*CONTENT-TYPES-FOR-URL-REWRITE*</clix:ref> and
          unless the client has already sent a cookie
          named <clix:ref>*SESSION-COOKIE-NAME*</clix:ref>.
          <p>
            Note that the function which rewrites the body doesn't
            understand Javascript, so you have to take care of URLs in
            Javascript code yourself.
          </p>
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*content-types-for-url-rewrite*">
        <clix:description>
          This is a list of strings (the initial value is
          <code>("text/html" "application/xhtml+xml")</code>) the
          content-type of an outgoing body is compared with
          if <clix:ref>*REWRITE-FOR-SESSION-URLS*</clix:ref> is true. If
          the content-type starts with one of these strings, then
          url-rewriting will happen, otherwise it won't.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*session-cookie-name*">
        <clix:description>
          This is the name that is used for the session-related cookie
          or GET parameter sent to the client. Its default value
          is <code>"hunchentoot-session"</code>. Note that changing this
          name while Hunchentoot is running will invalidate existing
          sessions.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*session-removal-hook*">
        <clix:description>
          The value of this variable should be a function of one
          argument, a <code>SESSION</code> object. This function is
          called directly before the session is destroyed, either
          by <clix:ref>RESET-SESSIONS</clix:ref> ,
          by <clix:ref>REMOVE-SESSION</clix:ref> , or when it's
          invalidated because it's too old.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*session-max-time*">
        <clix:description>
          The default time (in seconds) after which a session times out
          - see <clix:ref>SESSION-MAX-TIME</clix:ref>.  This value is
          initially set to 1800.
        </clix:description>
      </clix:special-variable>

      <clix:function macro="true" name="do-sessions">
        <clix:lambda-list>(var <clix:lkw>optional</clix:lkw> result-form) statement*</clix:lambda-list>
        <clix:returns>result</clix:returns>
        <clix:description>
          Executes the statements with <clix:arg>var</clix:arg> bound to
          each existing <code>SESSION</code> object consecutively. An
          implicit block named <code>NIL</code> surrounds the body of
          this macro. Returns the values returned
          by <clix:arg>result-form</clix:arg> unless
          <code>RETURN</code> is executed. The scope of the binding of
          <clix:arg>var</clix:arg> does <em>not</em> include
          <clix:arg>result-form</clix:arg>.
        </clix:description>
      </clix:function>

      <clix:special-variable name="*session-gc-frequency*">
        <clix:description>
          A session garbage collection
          (see <clix:ref>SESSION-GC</clix:ref>) will happen every
          <clix:ref>*SESSION-GC-FREQUENCY*</clix:ref> requests (counting
          only requests which use sessions) if the value of this
          variable is not <code>NIL</code>.  It's default value is 50.
        </clix:description>
      </clix:special-variable>

      <clix:function name="session-gc">
        <clix:returns>|</clix:returns>
        <clix:description>
          Deletes sessions which are too old - see
          <clix:ref>SESSION-TOO-OLD-P</clix:ref>.  Usually, you don't call
          this function directly -
          see <clix:ref>*SESSION-GC-FREQUENCY*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="session-too-old-p">
        <clix:lambda-list>session</clix:lambda-list>
        <clix:returns>generalized-boolean</clix:returns>
        <clix:description>
          Returns a true value if the <code>SESSION</code>
          object <clix:arg>session</clix:arg>
          is <a href="#session-max-time">too old</a> and would be
          deleted during the next <a href="#session-gc">session GC</a>.
          You don't have to check this manually for sessions
          in <clix:ref>*SESSION*</clix:ref> , but it might be useful if
          you want to <a href="#do-sessions">loop through all
            sessions</a>.
        </clix:description>
      </clix:function>
    </clix:subchapter>

    <clix:subchapter name="log" title="Logging and error handling">

      By default, Hunchentoot logs accesses and errors to two
      separate files in the file system.  Access logging is done in
      a format similar to what the Apache web server can write so
      that logfile analysis using standard tools is possible.
      Errors during request processing are logged to a separate
      file.  The default locations of the log files are
      implementation dependent.
      <p>
        If you intend to use Hunchentoots default logging facility,
        please note that the log files are kept open forever.  If
        you need to rotate your logs, reassign the log file name
        using <code>(SETF LOG-FILE)</code>
        or <code>(SETF ACCESS-LOG-FILE)</code>, which will close any
        opened log file before assigning the new name.
      </p>


      <p>
        The default logging behavior of Hunchentoot can be modified
        by supplying the <clix:arg>access-logger</clix:arg> and <clix:arg>message-logger</clix:arg> arguments
        to the <clix:ref>START-SERVER</clix:ref> function.
      </p>

      <p>
        Errors happening within a <a href="#handlers">handler</a>
        which are not caught by the handler itself are normally
        handled by Hunchentoot by logging them to the log file.
      </p>

      <clix:accessor name="log-file">
        <clix:returns>pathname</clix:returns>
        <clix:description>
          These functions can be used to query and set the location of
          the error log file.
        </clix:description>
      </clix:accessor>

      <clix:accessor name="access-log-file">
        <clix:returns>pathname</clix:returns>
        <clix:description>
          These functions can be used to query and set the location of
          the access log file.
        </clix:description>
      </clix:accessor>

      <clix:function generic="true" name="log-message">
        <clix:lambda-list>log-level format <clix:lkw>rest</clix:lkw> args</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Writes a message to <a href="#log-file">the current message
            log file</a>. <clix:arg>log-level</clix:arg> should be a
            keyword denoting a log
            level. <clix:arg>log-level</clix:arg> can also
            be <code>NIL</code>.  The log level is written to the log
            file unless it's <code>NIL</code>.
          <clix:arg>format</clix:arg> and <clix:arg>args</clix:arg> are used
          as with
          <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_format.htm">
            <code>FORMAT</code>
          </a>.
        </clix:description>
      </clix:function>

      <clix:special-variable name="*log-lisp-errors-p*">
        <clix:description>
          Whether unhandled errors
          in <clix:ref>*LISP-ERRORS-LOG-LEVEL*</clix:ref>. The default
          value is <code>T</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*lisp-errors-log-level*">
        <clix:description>
          The log level used to log Lisp errors. See
          also <clix:ref>*LOG-LISP-ERRORS-P*</clix:ref>. The default value
          is <code>:ERROR</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*log-lisp-warnings-p*">
        <clix:description>
          Whether unhandled warnings
          in <clix:ref>*LISP-WARNINGS-LOG-LEVEL*</clix:ref>. The default
          value is <code>T</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*lisp-warnings-log-level*">
        <clix:description>
          The log level used to log Lisp warnings. See
          also <clix:ref>*LOG-LISP-WARNINGS-P*</clix:ref>. The default
          value is <code>:WARNING</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*log-lisp-backtraces-p*">
        <clix:description>
          Whether backtraces should also be logged in addition to error
          messages and warnings. This value will only have effect
          if <clix:ref>*LOG-LISP-ERRORS-P*</clix:ref>
          or <clix:ref>*LOG-LISP-WARNINGS-P*</clix:ref> is <em>true</em>.
          The default value is <code>NIL</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*show-lisp-errors-p*">
        <clix:description>
          Whether unhandled Lisp errors should be shown to the user. If
          this value is <code>NIL</code> (which is the default), only
          the message <em>An error has occurred</em> will be shown.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*show-lisp-backtraces-p*">
        <clix:description>
          Whether backtraces should also be shown to the user. This
          value will only have effect
          if <clix:ref>*SHOW-LISP-ERRORS-P*</clix:ref> is <em>true</em>.
          The default value is <code>NIL</code>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*http-error-handler*">
        <clix:description>
          This variable holds <code>NIL</code> (the default) or
          a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator">function
            designator</a> for a function of one argument. The function
          gets called if the
          responsible <clix:ref>*APPROVED-RETURN-CODES*</clix:ref>
          and <clix:ref>*HANDLE-HTTP-ERRORS-P*</clix:ref> is true.  It
          receives the return code as its argument and can return the
          contents of an error page or <code>NIL</code> if it refuses to
          handle the error, i.e. if Hunchentoot's default error page
          should be shown. (Note that the function can access the
          request and reply data.)
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*handle-http-errors-p*">
        <clix:description>
          This variable holds a generalized boolean that determines
          whether return codes not
          in <clix:ref>*APPROVED-RETURN-CODES*</clix:ref> are treated
          specially.  When its value is true (the default), either a
          default body for the return code or the result of
          calling <clix:ref>*HTTP-ERROR-HANDLER*</clix:ref> is used.  When
          the value is <code>NIL</code>, no special action is taken and
          you are expected to supply your own response body to describe
          the error.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*approved-return-codes*">
        <clix:description>
          A list of return codes the server should not treat as an error
          - see <clix:ref>*HANDLE-HTTP-ERRORS-P*</clix:ref>.  The initial
          value is the list with the values of
          <clix:ref>+HTTP-OK+</clix:ref>, <clix:ref>+HTTP-NO-CONTENT+</clix:ref>, <clix:ref>+HTTP-MULTI-STATUS+</clix:ref>,
          and <clix:ref>+HTTP-NOT-MODIFIED+</clix:ref>.
        </clix:description>
      </clix:special-variable>

      <clix:function name="get-backtrace">
        <clix:lambda-list>condition</clix:lambda-list>
        <clix:returns>backtrace</clix:returns>
        <clix:description>
          This is the function that is used internally by Hunchentoot to
          show or log backtraces.  It accepts a condition
          object <clix:arg>condition</clix:arg> and returns a string with
          the corresponding backtrace.
        </clix:description>
      </clix:function>
    </clix:subchapter>

    <clix:subchapter name="debug" title="Debugging Hunchentoot applications">

      The best option to debug a Hunchentoot application is probably
      to use the debugger of your Lisp implementation.  In order to
      prevent Hunchentoot from catching errors detected during request
      execution, use
      the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_break_.htm"><code>*BREAK-ON-SIGNALS*</code></a>
      special variable.

      <p>
        Often, it is helpful to see what the headers of the request
        and response are.  The <clix:ref>*header-stream*</clix:ref> is
        useful for this.
      </p>

      <p>
        Finally, debugging multi threaded applications is often harder
        than single threaded ones.  If
        you <a href="#start-server">start</a> your Hunchentoot server
        with the <i>THREADED</i> argument set to NIL, it will run in
        the foreground, process one request after the other and fail
        synchronously if it fails.
      </p>
      
      <p>
        Good luck... :)
      </p>

      <clix:special-variable name="*header-stream*">
        <clix:description>
          If this variable is not <code>NIL</code>, it should be bound
          to a stream to which incoming and outgoing headers will be
          written for debugging purposes.
        </clix:description>
      </clix:special-variable>
    </clix:subchapter>

    <clix:subchapter name="misc" title="Miscellaneous">

      Various functions and variables which didn't fit into one of the
      other categories.

      <clix:function name="ssl-p">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> server</clix:lambda-list>
        <clix:returns>generalized-boolean</clix:returns>
        <clix:description>
          Whether the current connection to the client is secure.
        </clix:description>
      </clix:function>

      <clix:symbol name="handler-done">
        <clix:description>
          This is
          a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#catch_tag">
            <em>catch tag</em></a> which names
          a <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#catch">
            <em>catch</em></a> which is active during the lifetime of
          a <a href="#handlers">handler</a>. The handler can at any
          time <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_t.htm#throw">
            <em>throw</em></a> the outgoing content body
          (or <code>NIL</code>) to this catch to immediately abort
          handling the request. See the source code
          of <clix:ref>REDIRECT</clix:ref> for an example.
        </clix:description>
      </clix:symbol>

      <clix:function name="no-cache">
        <clix:returns>|</clix:returns>
        <clix:description>
          This function will set appropriate outgoing headers to
          completely prevent caching on virtually all browsers.
        </clix:description>
      </clix:function>

      <clix:function name="handle-if-modified-since">
        <clix:lambda-list>time <clix:lkw>optional</clix:lkw> request</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          This function is designed to be used inside
          a <a href="#handlers">handler</a>. If the client has sent an
          'If-Modified-Since' header
          (see <a href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>,
          section 14.25) and the time specified matches the universal
          time
          <clix:arg>time</clix:arg> then the
          header <clix:ref>+HTTP-NOT-MODIFIED+</clix:ref> with no content
          is immediately returned to the client.
          <p>
            Note that for this function to be useful you should usually
            send 'Last-Modified' headers back to the client. See the
            code
            of <clix:ref>CREATE-STATIC-FILE-DISPATCHER-AND-HANDLER</clix:ref>
            for an example.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="rfc-1123-date">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> time</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          This function accepts a universal time <clix:arg>time</clix:arg>
          (default is the current time) and returns a string which
          encodes this time according
          to <a href="http://www.faqs.org/rfcs/rfc1123.html">RFC 1123</a>. This
          can be used to send a 'Last-Modified' header -
          see <clix:ref>HANDLE-IF-MODIFIED-SINCE</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="redirect">
        <clix:lambda-list>target <clix:lkw>key</clix:lkw> host port protocol add-session-id code</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Sends back appropriate headers to redirect the client
          to <clix:arg>target</clix:arg> (a string).
          <p>
            If <clix:arg>target</clix:arg> is a full URL starting with a
            scheme, <clix:arg>host</clix:arg>, <clix:arg>port</clix:arg>,
            and <clix:arg>protocol</clix:arg> are ignored.
            Otherwise, <clix:arg>target</clix:arg> should denote the path
            part of a URL, <clix:arg>protocol</clix:arg> must be one of
            the keywords <code>:HTTP</code> or <code>:HTTPS</code>, and
            the URL to redirect to will be constructed
            from <clix:arg>host</clix:arg>, <clix:arg>port</clix:arg>, <clix:arg>protocol</clix:arg>,
            and <clix:arg>target</clix:arg>.
          </p>
          <p>
            If <clix:arg>code</clix:arg> is a 3xx redirection code, it
            will be sent as status code.  In case of <code>NIL</code>, a
            302 status code will be sent to the client.
            If <clix:arg>host</clix:arg> is not provided, the current host
            (see <clix:ref>HOST</clix:ref>) will be
            used. If <clix:arg>protocol</clix:arg> is the
            keyword <code>:HTTPS</code>, the client will be redirected
            to a https URL, if it's <code>:HTTP</code> it'll be sent to
            a http URL.  If both <clix:arg>host</clix:arg>
            and <clix:arg>protocol</clix:arg> aren't provided, then the
            value of <clix:arg>protocol</clix:arg> will match the current
            request.
          </p>
        </clix:description>
      </clix:function>

      <clix:function name="require-authorization">
        <clix:lambda-list><clix:lkw>optional</clix:lkw> realm</clix:lambda-list>
        <clix:returns>|</clix:returns>
        <clix:description>
          Sends back appropriate headers to require basic HTTP
          authentication
          (see <a href="http://www.faqs.org/rfcs/rfc2617.html">RFC 2617</a>)
          for the realm <clix:arg>realm</clix:arg>. The default value
          for <clix:arg>realm</clix:arg> is <code>"Hunchentoot"</code>.
        </clix:description>
      </clix:function>

      <clix:function name="escape-for-html">
        <clix:lambda-list>string</clix:lambda-list>
        <clix:returns>escaped-string</clix:returns>
        <clix:description>
          Escapes all occurrences of the
          characters <code>#\&lt;</code>, <code>#\&gt;</code>, <code>#\'</code>, <code>#&#34;</code>,
          and <code>#\&amp;</code> within <clix:arg>string</clix:arg> for
          HTML output.
        </clix:description>
      </clix:function>

      <clix:function name="url-encode">
        <clix:lambda-list>string <clix:lkw>optional</clix:lkw> external-format</clix:lambda-list>
        <clix:returns>url-encoded-string</clix:returns>
        <clix:description>
          URL-encodes a string using the external
          format <clix:arg>external-format</clix:arg>.  The default
          for <clix:arg>external-format</clix:arg> is the value
          of <clix:ref>*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="url-decode">
        <clix:lambda-list>string <clix:lkw>optional</clix:lkw> external-format</clix:lambda-list>
        <clix:returns>url-encoded-string</clix:returns>
        <clix:description>
          URL-decodes a string using the external
          format <clix:arg>external-format</clix:arg>, i.e. this is the
          inverse of <clix:ref>URL-ENCODE</clix:ref>.  It is assumed that
          you'll rarely need this function, if ever.  But just in case -
          here it is.  The default
          for <clix:arg>external-format</clix:arg> is the value
          of <clix:ref>*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*</clix:ref>.
        </clix:description>
      </clix:function>

      <clix:function name="http-token-p">
        <clix:lambda-list>object</clix:lambda-list>
        <clix:returns>generalized-boolean</clix:returns>
        <clix:description>
          This function tests whether <clix:arg>object</clix:arg> is a
          non-empty string which is a <em>token</em> according
          to <a href="http://www.faqs.org/rfcs/rfc2068.html">RFC
            2068</a> (i.e. whether it may be used for, say, cookie names).
        </clix:description>
      </clix:function>

      <clix:special-variable name="*tmp-directory*">
        <clix:description>
          This should be a pathname denoting a directory where temporary
          files can be stored. It is used for <a href="#upload">file
            uploads</a>.
        </clix:description>
      </clix:special-variable>

      <clix:special-variable name="*hunchentoot-default-external-format*">
        <clix:description>
          The (<a href="http://weitz.de/flexi-streams/">flexi
            stream</a>) external format used when computing
          the <clix:ref>REQUEST</clix:ref> object.  The default value is
          the result of evaluating
          <pre>(<a class="noborder" href="http://weitz.de/flexi-streams/#make-external-format">flex:make-external-format</a> :latin1 :eol-style :lf)
          </pre>
        </clix:description>
      </clix:special-variable>

      <clix:function name="mime-type">
        <clix:lambda-list>pathspec</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Given a pathname designator <clix:arg>pathspec</clix:arg>
          returns
          the <a href="http://en.wikipedia.org/wiki/Internet_media_type">MIME
            type</a> (as a string) corresponding to the suffix of the file
          denoted by
          <clix:arg>pathspec</clix:arg> (or <code>NIL</code> if none can
          be found).  This is based on the table coming with the Apache
          distribution with some additions.
        </clix:description>
      </clix:function>

      <clix:function name="reason-phrase">
        <clix:lambda-list>return-code</clix:lambda-list>
        <clix:returns>string</clix:returns>
        <clix:description>
          Returns a reason phrase for the HTTP return
          code <clix:arg>return-code</clix:arg> (which should be an
          integer) or <code>NIL</code> for return codes Hunchentoot
          doesn't know.
        </clix:description>
      </clix:function>
    </clix:subchapter>
  </clix:chapter>

  <clix:chapter name="performance" title="Performance">

    If you're concerned about Hunchentoot's performance, you should
    first and foremost check if you aren't wasting your time with
    premature optimization.  Make a reasonable estimate of the amount
    of traffic your website should be able to handle and don't try to
    benchmark for loads Google would be proud of.  Here's a part of an
    interview with someone called John Witchel about his experiences
    with his company <em>Red Gorilla</em> that can't be quoted often
    enough (it seems the original source of the interview has
    vanished):

    <blockquote>
      <b>Q:</b> If you could go back and change anything, would <em>Red Gorilla</em> still be
      in business today?
      <p>
        <b>A:</b> Yes. I would start small and grow as the demand
        grew. That's what I'm doing now.
      </p>
      <p>
        Back then we planned to be huge from the outset. So we built
        this monster platform on BEA, Sun and Oracle. We had huge
        dedicated connectivity pipes. We had two full racks clustered
        and fully redundant. We had E450's with RAID-5 and all 4 CPU
        slots filled, E250s, F5 load balancers... the cost of keeping
        that system on was enormous. The headcount to keep it humming
        was enormous too.
      </p>
      <p>
        The truth is, we could have run the whole company on my laptop
        using a cable modem connection.
      </p>
    </blockquote>

    Having said that, my experience is that Hunchentoot doesn't have
    to hide when it comes to
    serving <a href="#handle-static-file">static files</a>.  If
    you <em>really</em> have performance problems with Hunchentoot,
    there are two things I'm aware of you should watch out for.
    <ul>
      <li>
        Check how your Lisp implementation implements
        multi-processing.  While I write this (April 2007), some
        Lisps, like CMUCL, still use their
        own <a href="http://en.wikipedia.org/wiki/Multithreading">
          <em>green</em> threads</a>, and some others, like AllegroCL
        and LispWorks, use OS-threads but allow only one Lisp thread
        at a time.  Unless you're using a Lisp that employs "real"
        symmetric multi-processing like SBCL (on some platforms) or
        Clozure MCL, you shouldn't compare apples with oranges.
        (Note: For CMUCL, you also shouldn't forget to use the
        dreaded <a href="http://wiki.alu.org/Lisp_Gotchas">
          <code>MP::STARTUP-IDLE-AND-TOP-LEVEL-LOOPS</code></a>.)
      </li>
      <li>
        It is preferable to read the request body in one go,
        using <clix:ref>RAW-POST-DATA</clix:ref> instead of reading
        the request body using a flexi stream.  Usually, this is
        automatically done right by Hunchentoot to read POST data, and
        you should only use the <clix:arg>want-stream</clix:arg>
        keyword argument to the <clix:ref>RAW-POST-DATA</clix:ref> in
        rare circumstances.
      </li>
    </ul>
  </clix:chapter>

  <clix:chapter name="testing" title="Testing">
    Hunchentoot comes with a test script that verifies that the
    example web server responds as expected.  This test script uses the
    <a href="http://weitz.de/drakma/">Drakma</a> HTTP client library
    and thus shares a significant amount of its base code with
    Hunchentoot itself.  Still, running the test script is a useful
    confidence test, and it is also possible to run the script across
    machines in order to verify a new Hunchentoot (or, for that matter
    Drakma) port.
    <p>
      To run the confidence test, start
      the <clix:ref>example</clix:ref> web server.  Then, in your Lisp
      listener, type
<pre>(hunchentoot-test:test-hunchentoot "http://localhost:4242")</pre>
      You will see some diagnostic output and a summary line that
      reports whether any tests have failed.  (You can also use the
      example certificate and key files in the test directory and
      start and test an https server instead.)
    </p>

    <clix:function name="hunchentoot-test:test-hunchentoot">
      <clix:lambda-list>base-url <clix:lkw>key</clix:lkw></clix:lambda-list>
      <clix:returns>|</clix:returns>
      <clix:description>
        Run the built-in confidence
        test.  <clix:arg>base-url</clix:arg> is the base URL to use
        for testing, it should not have a trailing slash.  The keyword
        arguments accepted are for future extension and should not
        currently be used.
        <p>
          The script expects the Hunchentoot example test server to be
          running at the given <clix:arg>base-url</clix:arg> and
          retrieves various pages from that server, expecting certain
          responses.
        </p>
      </clix:description>
    </clix:function>

  </clix:chapter>

  <clix:chapter name="history" title="History">

    Hunchentoot's predecessor <a href="http://weitz.de/tbnl/">TBNL</a>
    (which is short for "To Be Named Later") grew over the years as a
    toolkit that I used for various commercial and private
    projects. In August 2003, Daniel Barlow started
    a <a href="http://article.gmane.org/gmane.lisp.web/148">review of
      web APIs</a> on
    the <a href="http://www.red-bean.com/lispweb/">lispweb</a> mailing
    list and
    I <a href="http://article.gmane.org/gmane.lisp.web/153">described</a>
    the API of my hitherto-unreleased bunch of code (and christened it
    "TBNL").
    <p>
      It turned out that
      <a href="http://www.jeffcaldwell.com/">Jeff Caldwell</a> had
      worked on something similar so he emailed me and proposed to
      join our efforts. As I had no immediate plans to release my code
      (which was poorly organized, undocumented, and mostly
      CMUCL-specific), I gave it to Jeff and he worked towards a
      release. He added docstrings, refactored, added some stuff, and
      based it on KMRCL to make it portable across several Lisp
      implementations.
    </p>
    <p>
      Unfortunately, Jeff is at least as busy as I am so he didn't
      find the time to finish a full release.  But in spring 2004 I
      needed a documented version of the code for a client of mine who
      thought it would be good if the toolkit were publicly available
      under an open source license. So I took Jeff's code, refactored
      again (to sync with the changes I had done in the meantime), and
      added documentation.  This resulted in TBNL 0.1.0 (which
      initially required mod_lisp as its front-end).
    </p>
    <p>
      In March 2005, Bob Hutchinson sent patches which enabled TBNL to
      use other front-ends than mod_lisp.  This made me aware that
      TBNL was already <em>almost</em> a full web server, so
      eventually I wrote Hunchentoot which <em>was</em> a full web
      server, implemented as a wrapper around TBNL.  Hunchentoot 0.1.0
      was released at the end of 2005 and was originally
      LispWorks-only.
    </p>
    <p>
      Hunchentoot 0.4.0, released in October 2006, was the first
      release which also worked with other Common Lisp
      implementations.  It is a major rewrite and also incorporates
      most of TBNL and replaces it completely.
    </p>
    <p>
      Hunchentoot 1.0.0, released in February 2009, is again a major
      rewrite and should be considered work in progress.  It moved to
      using
      the <a href="http://common-lisp.net/project/usocket/">usocket</a>
      and <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a> for non-LispWorks Lisps, thereby removing most of
      the platform dependent code.  Threading behaviour was made
      controllable through the introduction of
      taskmasters.  <a href="http://www.cliki.net/mod_lisp">mod_lisp</a>
      support and several other things were removed in this release to
      simplify the code base (and partly due to the lack of interest).
      Several architectural changes (lots of them not
      backwards-compatible) were made to ease customization of
      Hunchentoot's behaviour.  A significant part of the 1.0.0
      redesign was done
      by <a href="http://netzhansa.blogspot.com/">Hans Hübner</a>.
    </p>
  </clix:chapter>

  <clix:chapter name="index" title="Symbol index">

    Here are all exported symbols of the <code>HUNCHENTOOT</code>
    package in alphabetical order linked to their corresponding
    documentation entries:

    <clix:index/>

  </clix:chapter>

  <clix:chapter name="ack" title="Acknowledgements">

    Thanks to Jeff Caldwell - TBNL would not have been released
    without his efforts. Thanks
    to <a href="http://www.fractalconcept.com/">Marc Battyani</a> for
    mod_lisp and to <a href="http://www.swiss.ai.mit.edu/~cph/">Chris
    Hanson</a> for mod_lisp2. Thanks
    to <a href="http://www.cliki.net/Stefan%20Scholl">Stefan
    Scholl</a> and Travis Cross for various additions and fixes to
    TBNL, to <a href="http://www.foldr.org/~michaelw/">Michael
    Weber</a> for initial file upload code, and
    to <a href="http://www.ltn.lv/~jonis/">Janis Dzerins</a> for
    his <a href="http://common-lisp.net/project/rfc2388/">RFC 2388
    code</a>. Thanks to Bob Hutchison for his code for multiple
    front-ends (which made me realize that TBNL was already pretty
    close to a "real" web server) and the initial UTF-8 example.
    Thanks to <a href="http://netzhansa.blogspot.com/">Hans Hübner</a>
    for a lot of architectural and implementation enhancements for the
    1.0.0 release and also for transferring the documentation to sane
    XHTML.  Thanks to John
    Foderaro's <a href="http://opensource.franz.com/aserve/index.html">AllegroServe</a>
    for inspiration.  Thanks to <a href="http://www.htg1.de/">Uwe von
    Loh</a> for
    the <a href="http://www.htg1.de/hunchentoot/hunchentoot.html">Hunchentoot
    logo</a>.
    
    <p>
      Hunchentoot originally used code
      from <a href="http://www.cliki.net/ACL-COMPAT">ACL-COMPAT</a>,
      specifically the chunking code from Jochen Schmidt.  (This has been
      replaced by <a href="http://weitz.de/chunga/">Chunga</a>.)  When I ported
      Hunchentoot to other Lisps than LispWorks, I stole code from
      ACL-COMPAT, <a href="http://www.cliki.net/kmrcl">KMRCL</a>,
      and <a href="http://www.cliki.net/trivial-sockets">trivial-sockets</a> for
      implementation-dependent stuff like sockets and MP.
    </p>
    <p>
      Parts of this documentation were prepared
      with <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>,
      no animals were harmed.
    </p>
  </clix:chapter>

  <p>
    $Header: /usr/local/cvsrep/hunchentoot/doc/index.html,v 1.141 2008/04/09 08:17:50 edi Exp $
  </p>
  <p>
    <a href="http://weitz.de/index.html">BACK TO MY HOMEPAGE</a>
  </p>
</clix:documentation>
