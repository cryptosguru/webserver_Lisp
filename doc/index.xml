<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="clixdoc.xsl" ?>

  <clix:documentation xmlns='http://www.w3.org/1999/xhtml' xmlns:clix='http://bknr.net/clixdoc'>
    <clix:title>HUNCHENTOOT - The Common Lisp web server formerly known as TBNL
    </clix:title>
  <clix:short-description>
    A fully-featured web server written in Common Lisp offering things
    like HTTP/1.1 chunking, persistent connections, and SSL.  Includes
    a framework for building dynamic websites interactively.
  </clix:short-description>

  <h2>
    <a href="http://www.htg1.de/hunchentoot/hunchentoot.html"
       title="Click here for the Hunchentoot logo"
       class="noborder">
      <img align="top" width="93" height="45" border="0" src="hunchentoot.gif" />
    </a>
    HUNCHENTOOT - The Common Lisp web server formerly known as TBNL
  </h2>
    <blockquote>
      <clix:chapter name='abstract' title='Abstract'>

    <p>
      Hunchentoot is a web server written in Common Lisp and at the
      same time a toolkit for building dynamic websites.  As a
      stand-alone web server, Hunchentoot is capable of HTTP/1.1
      chunking (both directions), persistent connections
      (keep-alive), and SSL.
    </p>
    <p>
      Hunchentoot provides facilities like automatic session
      handling (with and without cookies), logging, customizable
      error handling, and easy access to GET and POST parameters
      sent by the client. It does <em>not</em> include functionality
      to programmatically generate HTML output. For this task you
      can use any library you like, e.g. (shameless self-plug)
      <a href="http://weitz.de/cl-who/">CL-WHO</a> or
      <a href="http://weitz.de/html-template/">HTML-TEMPLATE</a>.
    </p>
    <p>
      Hunchentoot talks with its front-end or with the client over
      TCP/IP sockets and optionally uses multiprocessing to handle
      several requests at the same time.  Therefore, it cannot be
      implemented completely in
      <a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">portable
        Common Lisp</a>.  It currently works "natively" with 
      <a href="http://www.lispworks.com/">LispWorks</a> (which is the
      main development and testing platform), and additionally on all
      Lisps which are supported by the compatibility
      layers <a href="http://common-lisp.net/project/usocket/">usocket</a>
      and <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a>.
    </p>
    <p>
      Hunchentoot comes with a 
      <a href="http://www.opensource.org/licenses/bsd-license.php">BSD-style
        license</a> so you can basically do with it whatever you want.
    </p>
    <p>
      Hunchentoot is for example used by 
      <a href="http://www.thoughtcrime.us/tp/">Trip Planner</a>, 
      <a href="http://clutu.com/">clutu</a>, 
      <a href="http://twitterbuzz.com/">TwitterBuzz</a>, 
      <a href="http://www.jalat.com/">Jalat</a>, 
      <a href="http://heikestephan.de/">Heike Stephan</a>, 
      <a href="http://www.memetrics.com/">xOs</a>, and 
      <a href="http://syseng.nist.gov/moss">the</a> 
      <a href="http://syseng.nist.gov/se-interop">NIST</a>.
    </p>
    <p>
      <font color="red">Download shortcut:</font>
      <a href="http://weitz.de/files/hunchentoot.tar.gz">http://weitz.de/files/hunchentoot.tar.gz</a>.
    </p>
      </clix:chapter>
    </blockquote>
    <clix:chapter name='contents' title='Contents'></clix:chapter>
    <clix:contents></clix:contents>
  <clix:chapter name="install" title="Download and installation">

    Hunchentoot depends on a couple of other Lisp libraries which you'll need
    to install first:
    <ul>
      <li>Pierre R. Mai's <a href="http://www.cliki.net/md5">MD5</a>,</li>
      <li>Kevin Rosenberg's <a href="http://www.cliki.net/cl-base64">CL-BASE64</a>,</li>
      <li>Janis Dzerins' <a href="http://common-lisp.net/project/rfc2388/">RFC2388</a>,</li>
      <li>Peter Seibel's <a href="http://weitz.de/cl-fad/">CL-FAD</a>,</li>
      <li>Erik Huelsmann's <a href="http://common-lisp.net/project/usocket">usocket</a> (unless you're using LispWorks),</li>
      <li>Greg Pfeil's <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
          Threads</a> (unless you're using LispWorks),
      </li>
      <li>
        David Lichteblau's <a href="http://common-lisp.net/project/cl-plus-ssl/">CL+SSL</a>
        (unless you're using LispWorks),
      </li>
      <li>
        and my own <a href="http://weitz.de/flexi-streams/">FLEXI-STREAMS</a> (0.12.0 or higher),
        <a href="http://weitz.de/chunga/">Chunga</a> (0.5.0 or
          higher), and <a href="http://weitz.de/cl-ppcre/">
          CL-PPCRE</a> (plus
        <a href="http://weitz.de/cl-who/">CL-WHO</a> for the <a href="#start">example code</a> and <a href="http://weitz.de/drakma/">Drakma</a> for the <a href="#testing">tests</a>.). 
      </li>
    </ul>

    Make sure to use the <em>newest</em> versions of all of these
    libraries (which might themselves depend on other libraries) - try
    the repository versions if you're in doubt.  Note: You can compile
    Hunchentoot without SSL support - and thus without the need to
    have CL+SSL - if you add
    <code>:HUNCHENTOOT-NO-SSL</code> to
    <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_featur.htm">
      <code>*FEATURES*</code></a> <em>before</em> you compile it.
    <p>
      Hunchentoot will only work with Lisps where
      the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_c.htm#character_code">character
      codes</a> of
      all <a href="http://en.wikipedia.org/wiki/ISO_8859-1">Latin-1</a>
      characters coincide with their
      Unicode <a href="http://en.wikipedia.org/wiki/Code_point">code
      points</a> (which is the case for all current implementations I
      know).
    </p>
    <p>
      Hunchentoot itself together with this documentation can be
      downloaded from
      <a href="http://weitz.de/files/hunchentoot.tar.gz">http://weitz.de/files/hunchentoot.tar.gz</a>.
      The current version is 1.0.0.
    </p>
    <p>
      The preferred method to compile and load Hunchentoot is via
      <a href="http://www.cliki.net/asdf">ASDF</a>.  If you think that
      it's too much work to find and download all the libraries
      mentioned above, try something like
      <a href="http://common-lisp.net/project/asdf-install/">ASDF-INSTALL</a>,
      <a href="http://common-lisp.net/project/clbuild/">clbuild</a>,
      or my own <a href="http://weitz.de/starter-pack/">Starter
        Pack</a>.  There's also a port for
      <a href="http://www.gentoo.org/proj/en/common-lisp/index.xml">Gentoo
        Linux</a> thanks to Matthew Kennedy.
    </p>
    <p>
      A <a href="http://www.selenic.com/mercurial/wiki/">Mercurial</a>
      repository of older versions is available at
      <a href="http://arcanes.fr.eu.org/~pierre/2007/02/weitz/">http://arcanes.fr.eu.org/~pierre/2007/02/weitz/</a>
      thanks to Pierre Thierry.
    </p>
    <p>
      Luís Oliveira maintains a <a href="http://darcs.net/">darcs</a>
      repository of Hunchentoot at
      <a href="http://common-lisp.net/~loliveira/ediware/">http://common-lisp.net/~loliveira/ediware/</a>.
    </p>

    <clix:subchapter name="proxy" title="Hunchentoot behind a proxy">

      If you're feeling unsecure about exposing Hunchentoot to the wild,
      wild Internet or if your Lisp web application is part of a larger
      website, you can hide it behind a
      <a href="http://en.wikipedia.org/wiki/Proxy_server">proxy server</a>.
      One approach that I have used several times is to employ Apache's
      <a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html">mod_proxy</a>
      module with a configuration that looks like this:

<pre><a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html#proxypass" class="noborder">ProxyPass</a> /hunchentoot http://127.0.0.1:3000/hunchentoot
<a href="http://httpd.apache.org/docs/2.0/mod/mod_proxy.html#proxypassreverse" class="noborder">ProxyPassReverse</a> /hunchentoot http://127.0.0.1:3000/hunchentoot</pre>

      This will tunnel all requests where the URI path begins with
      <code>"/hunchentoot"</code> to a (Hunchentoot) server listening on
      port 3000 on the same machine.

      <p>
        Of course, there are
        <a href="http://www.red-bean.com/pipermail/lispweb/2006-October/001342.html">several
          other</a> (more lightweight) web proxies that you could use
        instead of Apache.
      </p>
    </clix:subchapter>
  </clix:chapter>

  <clix:chapter name="mail" title="Support and mailing lists">

    For questions, bug reports, feature requests, improvements, or
    patches please use the
    <a href="http://common-lisp.net/mailman/listinfo/tbnl-devel">tbnl-devel
      mailing list</a>. If you want to be notified about future
    releases subscribe to the
    <a href="http://common-lisp.net/mailman/listinfo/tbnl-announce">tbnl-announce
      mailing list</a>. These mailing lists were made available thanks
    to the services of
    <a href="http://common-lisp.net/">common-lisp.net</a>.  You can
    <b>search</b> the devel mailing list
    <a href="http://google.com/coop/cse?cx=002927904911724867201%3A0l5rif_cxj0">here</a>
    (thanks to Tiarnán Ó Corráin).
    <p>
      If you want to send patches, please
      <a href="http://weitz.de/patches.html">read this first</a>.
    </p>
  </clix:chapter>

  <clix:chapter name="start" title="Your own webserver (the easy teen-age New York version)">
    Starting your own web server is pretty easy.  Do something like this:
<pre>(hunchentoot:<a class="noborder" href="#start">start</a> (make-instance 'hunchentoot:<a class="noborder" href="#acceptor">acceptor</a> :port 4242))</pre>
    That's it.  Now you should be able to enter the address
    "<a href='http://127.0.0.1:4242/'><code>http://127.0.0.1:4242/</code></a>" in
    your browser and see something, albeit nothing very interesting
    for now.

    <p>
      Now be a bit more adventurous, try this
<pre>(hunchentoot:<a class="noborder" href="#define-easy-handler">define-easy-handler</a> (say-yo :uri "/yo") (name)
  (setf (hunchentoot:<a class="noborder" href="#content-type*">content-type*</a>) "text/plain")
  (format nil "Hey~@[ ~A~]!" name))</pre>
      and see what happens at "<a href='http://127.0.0.1:4242/yo'><code>http://127.0.0.1:4242/yo</code></a>" or
      "<a href='http://127.0.0.1:4242/yo?name=Dude'><code>http://127.0.0.1:4242/yo?name=Dude</code></a>" .

    </p>

    <p>
    Hunchentoot comes with a little example website which you can use
    to see if it works and which should also demonstrate a couple of
    the things you can do with Hunchentoot.  To start the example
    website, enter the following code into your listener:

<pre>(<a class="noborder" href="http://common-lisp.net/~mmommer/asdf-howto.shtml#sec11">asdf:oos</a> 'asdf:load-op :hunchentoot-test)</pre>

    Now go to "<a href='http://127.0.0.1:4242/hunchentoot/test'><code>http://127.0.0.1:4242/hunchentoot/test</code></a>" and play a bit.
    </p>
  </clix:chapter>

  <clix:chapter name="tutorials" title="Tutorials and add-ons">

    <p>
      Here are some Hunchentoot tutorials done by others:
    </p>
    <ul>
      <li>
        <a href="http://www.adampetersen.se/articles/lispweb.htm">"Lisp for the Web"</a> by Adam Petersen.
      </li>
      <li>
        Two <a href="http://myblog.rsynnott.com/2007/09/getting-started-with-hunchento.html">getting</a>
        <a href="http://myblog.rsynnott.com/2007/10/doing-more-with-hunchentoot-cl-server.html">started</a>
        articles by Robert Synnott.
      </li>
      <li>
        <a href="http://www.newartisans.com/blog_files/common.lisp.with.apache.php">Running Common Lisp
          behind Apache</a> by John Wiegley.  (And there's a
        <a href="http://www.newartisans.com/blog_files/hunchentoot.primer.php">second part</a>.)
      </li>
      <li>
        A <a href="http://www.lispcast.com/index.php/2007/10/lispcast-writing-a-simple-reddit-clone-in-common-lisp/">"LispCast"</a>
        by Eric Normand about writing a <a href="http://reddit.com/">Reddit</a> clone using
        Hunchentoot.  Apparently the first part of a
        <a href="http://bc.tech.coop/blog/071028.html">series</a>.
      </li>
      <li>
        A <a href="http://roeim.net/vetle/docs/cl-webapp-intro/">tutorial</a> about
        implementing a blog in Common Lisp by Vetle Roeim.
      </li>
      <li>
        A <a href="http://www.jalat.com/blogs/lisp?id=3">tutorial</a> for (an older version of)
        Hunchentoot by Asbjørn Bjørnstad.
      </li>
      <li>
        A <a href="http://www.frank-buss.de/lisp/tbnl.html">TBNL tutorial</a> from Frank Buss.
        (Hunchentoot is not <a href="http://weitz.de/tbnl/">TBNL</a>, but the two are similar enough
        to make the tutorial worthwhile.)
      </li>
      <li>
        For Win32, Bill
        Clementson <a href="http://bc.tech.coop/blog/041105.html">explains</a>
        how to set up Hunchentoot's
        predecessor <a href="http://weitz.de/tbnl/">TBNL</a> with
        Apache/mod_lisp.  See
        also <a href="http://bc.tech.coop/blog/061013.html">http://bc.tech.coop/blog/061013.html</a>.
      </li>
    </ul>

    Check the dates of these tutorials!  Many of them might not be a
    perfect fit with the latest release of Hunchentoot as there have
    been several changes to its API recently, especially in 2009.
    Also, the fact that these tutorials are listed here doesn't
    necessarily mean that I endorse them or think that they show
    idiomatic Lisp code.  You'll have to decide yourself if they're
    helpful to you or not.

    <p>
      Here is some software which extends Hunchentoot or is based on it:
    </p>
    <ul>
      <li>
        <a href="http://common-lisp.net/project/cl-weblocks/">Weblocks</a>
        by Slava Akhmechet is a "continuations-based web framework" which is
        based on Hunchentoot.
      </li>
      <li>
        <a href="http://pen.two-bytes.com/misc/ht-ajax.html">HT-AJAX</a> is
        an <a href="http://en.wikipedia.org/wiki/Ajax_%28programming%29">Ajax</a>
        framework for Hunchentoot by Ury Marshak.
      </li>
      <li>
        Mac Chan
        <a href="http://common-lisp.net/pipermail/tbnl-devel/2007-May/001324.html">has
          ported <a href="http://lemonodor.com/">John Wiseman</a>'s
          <a href="http://www.lemonodor.com/archives/000128.html">Lisp
            Server Pages</a> to Hunchentoot.</a>
      </li>
      <li>
        <a href="http://site.znain.com/dl/lisp/hunchentoot-dir-lister/">hunchentoot-dir-lister</a>
        is a directory listing addition for Hunchentoot by Dimitre Liotev.
      </li>
      <li>
        Cyrus Harmon's
        <a href="http://cyrusharmon.org/blog/display?id=64">nuclblog</a> is a
        <a href="http://en.wikipedia.org/wiki/Blog">blog</a> engine which uses Hunchentoot.
      </li>
      <li>
        <a href="http://cyrusharmon.org/projects?project=hunchentoot-cgi">hunchentoot-cgi</a>
        (also by Cyrus Harmon) provides
        <a href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>
        handlers for Hunchentoot.
      </li>
      <li>
        <a href="http://weitz.de/cl-webdav/">CL-WEBDAV</a> is a <a href="http://webdav.org/">WebDAV</a>
        server based on Hunchentoot.
      </li>
    </ul>
  </clix:chapter>

  <clix:chapter name="reference" title="Function and variable reference">

    <clix:subchapter name="acceptors" title="Acceptors">

      If you want Hunchentoot to actually do something, you have to create and
      <a href="#start">start</a> an <a href="#acceptor">acceptor</a>.
      You can also run several acceptors in one image, each one
      listening on a different different port.

  <clix:class name='acceptor'>
    <clix:description>To create a Hunchentoot webserver, you make an
instance of this class and use the generic function <clix:ref>START</clix:ref> to start it
(and <clix:ref>STOP</clix:ref> to stop it).  Use the <code>:port</code> initarg if you don&#039;t want to
listen on the default http port 80.  There are other initargs most of
which you probably won&#039;t need very often.  They are explained in
detail in the docstrings of the slot definitions for this class.
<p>
Unless you are in a Lisp without MP capabilities, you can have several
active instances of <clix:ref>ACCEPTOR</clix:ref> (listening on different ports) at the
same time.</p>
    </clix:description>
  </clix:class>

  <clix:class name='ssl-acceptor'>
    <clix:description>Create and <clix:ref>START</clix:ref> an instance of this class
(instead of <clix:ref>ACCEPTOR</clix:ref>) if you want an https server.  There are two
required initargs, <code>:SSL-CERTIFICATE-FILE</code> and <code>:SSL-PRIVATEKEY-FILE</code>, for
pathname designators denoting the certificate file and the key file in
PEM format.  On LispWorks, you can have both in one file in which case
the second initarg is optional.  On LispWorks, you can also use the
<code>:SSL-PRIVATEKEY-PASSWORD</code> initarg to provide a password (as a string)
for the key file (or <code>NIL</code>, the default, for no password).  On other
Lisps, the key file must not be password-protected.
<p>
The default port for <clix:ref>SSL-ACCEPTOR</clix:ref> instances is 443 instead of 80
</p>
    </clix:description>
  </clix:class>

  <clix:function generic='true' name='start'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>acceptor
  </clix:returns>
    <clix:description>Starts <clix:arg>acceptor</clix:arg> so that it begins accepting
connections.  Returns the acceptor.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='stop'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>acceptor
  </clix:returns>
    <clix:description>Stops <clix:arg>acceptor</clix:arg> so that it
no longer accepts requests.
    </clix:description>
  </clix:function>

  <clix:special-variable name='*acceptor*'>
    <clix:description>The current ACCEPTOR object in the context of a request.
    </clix:description>
  </clix:special-variable>

  <clix:readers generic='true'>
    <clix:listed-reader name='acceptor-address'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>address
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-port'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>port
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-read-timeout'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>read-timeout
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-ssl-certificate-file'>
    <clix:lambda-list>ssl-acceptor
    </clix:lambda-list>
    <clix:returns>ssl-certificate-file
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-ssl-privatekey-file'>
    <clix:lambda-list>ssl-acceptor
    </clix:lambda-list>
    <clix:returns>ssl-privatekey-file
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-ssl-privatekey-password'>
    <clix:lambda-list>ssl-acceptor
    </clix:lambda-list>
    <clix:returns>ssl-privatekey-password
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='acceptor-write-timeout'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>write-timeout
    </clix:returns>
    </clix:listed-reader>

    <clix:description>
These are readers for various slots of <clix:ref>ACCEPTOR</clix:ref>
objects (and some of them obviously only make sense
for <clix:ref>SSL-ACCEPTOR</clix:ref> objects).  See the docstrings of
these slots for more information.
    </clix:description>
  </clix:readers>

  <clix:accessors generic='true'>
    <clix:listed-accessor name='acceptor-access-logger'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>access-logger
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-request-dispatcher'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>request-dispatcher
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-input-chunking-p'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>input-chunking-p
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-message-logger'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>message-logger
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-name'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>name
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-output-chunking-p'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>output-chunking-p
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-persistent-connections-p'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>persistent-connections-p
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-reply-class'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>reply-class
    </clix:returns>
    </clix:listed-accessor>

    <clix:listed-accessor name='acceptor-request-class'>
    <clix:lambda-list>acceptor
    </clix:lambda-list>
    <clix:returns>request-class
    </clix:returns>
    </clix:listed-accessor>

    <clix:description>
These are accessors for various slots of <clix:ref>ACCEPTOR</clix:ref>
objects.  See the docstrings of these slots for more information.
    </clix:description>
  </clix:accessors>

  <clix:special-variable name='*acceptor*'>
    <clix:description>The current ACCEPTOR object while in the context of a request.
    </clix:description>
  </clix:special-variable>


  <clix:function generic='true' name='acceptor-ssl-p'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>ssl-p
  </clix:returns>
    <clix:description>Returns a true value if <clix:arg>acceptor</clix:arg> uses SSL
connections.  The default is to unconditionally return <code>NIL</code> and
subclasses of <clix:ref>ACCEPTOR</clix:ref> must specialize this method to signal that
they&#039;re using secure connections - see the <clix:ref>SSL-ACCEPTOR</clix:ref> class.
    </clix:description>
  </clix:function>

  <clix:special-variable name='*default-connection-timeout*'>
    <clix:description>The default connection timeout used when an
acceptor is reading from and writing to a socket stream.  Note that
some Lisps allow you to set different timeouts for reading and writing
and you can specify both values via initargs when you create
an <a href="#acceptors">acceptor</a>.
    </clix:description>
  </clix:special-variable>

    </clix:subchapter>

    <clix:subchapter name="acceptor-behaviour" title="Acceptor behaviour">

If you want to modify what acceptors do, you should
subclass <clix:ref>ACCEPTOR</clix:ref>
(or <clix:ref>SSL-ACCEPTOR</clix:ref>) and specialize the generic
functions that constitute their behaviour.  The life of an acceptor
looks like this: It is started with the function <clix:ref>START</clix:ref> which
immediately calls <clix:ref>START-LISTENING</clix:ref> and then applies the function
<clix:ref>EXECUTE-ACCEPTOR</clix:ref> to
its <a href="#taskmasters">taskmaster</a>.  This function will
eventually call <clix:ref>ACCEPT-CONNECTIONS</clix:ref> which is
responsible for settings things up to wait for clients to connect.
For each connection which comes
in, <clix:ref>HANDLE-INCOMING-CONNECTION</clix:ref> is applied to the
taskmaster which will call <clix:ref>PROCESS-CONNECTION</clix:ref>.
<clix:ref>PROCESS-CONNECTION</clix:ref>
calls <clix:ref>INITIALIZE-CONNECTION-STREAM</clix:ref> before it does
anything else, then it selects and calls a function which handles
the <a href="#requests">request</a>, and finally it sends
the <a href="#replies">reply</a> to the client before it
calls <clix:ref>RESET-CONNECTION-STREAM</clix:ref>.  If the connection
is persistent, this procedure is repeated (except for the
intialization step) in a loop until the connection is closed.  The
acceptor is stopped with <clix:ref>STOP</clix:ref>.

<p>
If you just want to use the standard acceptors that come with
Hunchentoot, you don't need to know anything about the functions
listed in this section.
</p>

  <clix:function generic='true' name='start-listening'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Sets up a listen socket for the given acceptor and
enables it to listen to incoming connections.  This function is called
from the thread that starts the acceptor initially and may return
errors resulting from the listening operation (like &#039;address in use&#039;
or similar).
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='accept-connections'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>nil
  </clix:returns>
    <clix:description>In a loop, accepts a connection and hands it over
to the acceptor's taskmaster for processing using
<clix:ref>HANDLE-INCOMING-CONNECTION</clix:ref>. On LispWorks, this
function returns immediately, on other Lisps it returns only once the
acceptor has been stopped.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='process-connection'>
  <clix:lambda-list>acceptor socket
  </clix:lambda-list>
  <clix:returns>nil
  </clix:returns>
    <clix:description>This function is called by the taskmaster when a
new client connection has been established.  Its arguments are the
<clix:ref>ACCEPTOR</clix:ref> object and a LispWorks socket handle or a usocket socket
stream object in <clix:arg>socket</clix:arg>.  It reads the request headers, sets up the
<a href="#requests">request</a> and <a href="#replies">reply</a>
objects, and hands over to <clix:ref>PROCESS-REQUEST</clix:ref> which
selects and calls a handler for the request and sends its reply to the
client.  This is done in a loop until the stream has to be closed or
until a connection timeout occurs.

<p>
It is probably not a good idea to re-implement this method until you
really, really know what you're doing, but you can for example write
an around method specialized for your subclass
of <clix:ref>ACCEPTOR</clix:ref> which binds or rebinds special
variables which can then be accessed by
your <a href="#handlers">handlers</a>.
</p>
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='initialize-connection-stream'>
  <clix:lambda-list>acceptor stream
  </clix:lambda-list>
  <clix:returns>stream
  </clix:returns>
    <clix:description>Can be used to modify the stream which is used
to communicate between client and server before the request is read.
The default method of <clix:ref>ACCEPTOR</clix:ref> does nothing, but
see for example the method defined
for <clix:ref>SSL-ACCEPTOR</clix:ref>.  All methods of this generic
function <em>must</em> return the stream to use.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='reset-connection-stream'>
  <clix:lambda-list>acceptor stream
  </clix:lambda-list>
  <clix:returns>stream
  </clix:returns>
    <clix:description>Resets the stream which is used to communicate
between client and server after one request has been served so that it
can be used to process the next request.  This generic function is
called after a request has been processed and <em>must</em> return the
stream.
    </clix:description>
  </clix:function>

    </clix:subchapter>

    <clix:subchapter name="taskmasters" title="Taskmasters">

As a "normal" Hunchentoot user, you can completely ignore taskmasters
and skip this section.  But if you're still reading, here are the
dirty details: Each <a href="#acceptors">acceptor</a> has a taskmaster
associated with it at creation time.  It is the taskmaster's job to
distribute the work of accepting and handling incoming connections.
The acceptor calls the taskmaster if appropriate and the taskmaster
calls back into the acceptor.  This is done using the generic
functions described in this and
the <a href="#acceptor-behaviour">previous</a> section.  Hunchentoot
comes with two standard taskmaster implementations - one (which is the
default used on multi-threaded Lisps) which starts a new thread for
each incoming connection and one which handles all requests
sequentially.  It should for example be relatively straightforward to
create a taskmaster which allocates threads from a fixed pool instead
of creating a new one for each connection.
<p>
If you want to implement your own taskmasters, you should subclass
<clix:ref>TASKMASTER</clix:ref> and specialize the generic functions in this section.
</p>

  <clix:class name='taskmaster'>
    <clix:description>An instance of this class is responsible for
distributing the work of handling requests for its acceptor.
This is
an "abstract" class in the sense that usually only instances of
subclasses of <clix:ref>TASKMASTER</clix:ref> will be used.
    </clix:description>
  </clix:class>

  <clix:class name='one-thread-per-connection-taskmaster'>
    <clix:description>A taskmaster that starts one thread for listening
to incoming requests and one thread for each incoming connection.
<p>
This is the default taskmaster implementation for multi-threaded Lisp
implementations.
</p>
    </clix:description>
  </clix:class>

  <clix:class name='single-threaded-taskmaster'>
    <clix:description>A taskmaster that runs synchronously in the
thread where the <clix:ref>START</clix:ref> function was invoked (or
in the case of LispWorks in the thread started
by <a href="http://www.lispworks.com/documentation/lw51/LWRM/html/lwref-61.htm#marker-910861"><code>COMM:START-UP-SERVER</code></a>).
This is the simplest possible taskmaster implementation in that its
methods do nothing but calling their acceptor &quot;sister&quot;
methods - <clix:ref>EXECUTE-ACCEPTOR</clix:ref> calls <clix:ref>ACCEPT-CONNECTIONS</clix:ref>,
<clix:ref>HANDLE-INCOMING-CONNECTION</clix:ref> calls <clix:ref>PROCESS-CONNECTION</clix:ref>.
    </clix:description>
  </clix:class>

  <clix:function generic='true' name='execute-acceptor'>
  <clix:lambda-list>taskmaster
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>This is a callback called by the acceptor once it
has performed all initial processing to start listening for incoming
connections (see <clix:ref>START-LISTENING</clix:ref>).  It usually calls the
<clix:ref>ACCEPT-CONNECTIONS</clix:ref> method of the acceptor, but depending on the
taskmaster instance the method might be called from a new thread.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='handle-incoming-connection'>
  <clix:lambda-list>taskmaster socket
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>This function is called by the acceptor to start
processing of requests on a new incoming connection.  <clix:arg>socket</clix:arg> is the
usocket instance that represents the new connection (or a socket
handle on LispWorks).  The taskmaster starts processing requests on
the incoming connection by calling the <clix:ref>PROCESS-CONNECTION</clix:ref>
method of the acceptor instance.  The <clix:arg>socket</clix:arg> argument is passed to
<clix:ref>PROCESS-CONNECTION</clix:ref> as an argument.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='shutdown'>
  <clix:lambda-list>taskmaster
  </clix:lambda-list>
  <clix:returns>taskmaster
  </clix:returns>
    <clix:description>Shuts down the taskmaster, i.e. frees all resources
that were set up by it.  For example, a multi-threaded taskmaster
might terminate all threads that are currently associated with it.
This function is called by the acceptor's <clix:ref>STOP</clix:ref> method.
    </clix:description>
  </clix:function>

  <clix:accessor generic='true' name='taskmaster-acceptor'>
  <clix:lambda-list>taskmaster
  </clix:lambda-list>
  <clix:returns>acceptor
  </clix:returns>
    <clix:description>
This is an accessor for the slot of a <clix:ref>TASKMASTER</clix:ref>
object that links back to the <a href="#acceptors">acceptor</a> it is
associated with.
    </clix:description>
  </clix:accessor>

    </clix:subchapter>

    <clix:subchapter name="requests" title="Request objects">

For each incoming request, the <a href="#acceptors">acceptor</a>
creates a <clix:ref>REQUEST</clix:ref> object and makes it available
to <a href="#handlers">handlers</a> via the special variable
<clix:ref>*REQUEST*</clix:ref>.  This object contains all relevant
information about the request and this section collects the functions
which can be used to query such an object.
In all function where <clix:arg>request</clix:arg> is an
optional or keyword parameter, the default
is <clix:ref>*REQUEST*</clix:ref>.

<p>
If you need more fine-grained control over the behaviour of request
objects, you can subclass <clix:ref>REQUEST</clix:ref> and initialize
the <a href="#acceptor-request-class"><code>REQUEST-CLASS</code></a>
slot of the <clix:ref>ACCEPTOR</clix:ref> class accordingly.  The
acceptor will generate request objects of the class named by this
slot.
</p>

  <clix:class name='request'>
    <clix:description>Objects of this class hold all the information
about an incoming request.  They are created automatically by
acceptors and can be accessed by the
corresponding <a href="#handlers">handler</a>.

You should not mess with the slots of these objects directly, but you
can subclass <clix:ref>REQUEST</clix:ref> in order to implement your
own behaviour.  See
the <a href="#acceptor-request-class"><code>REQUEST-CLASS</code></a>
slot of the <clix:ref>ACCEPTOR</clix:ref> class.
    </clix:description>
  </clix:class>

  <clix:special-variable name='*request*'>
    <clix:description>The current REQUEST object while in the context of a request.
    </clix:description>
  </clix:special-variable>

  <clix:function name='real-remote-addr'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>string{, list}
  </clix:returns>
    <clix:description>Returns the &#039;<code>X-Forwarded-For</code>&#039; incoming http header as the
second value in the form of a list of IP addresses and the first
element of this list as the first value if this header exists.
Otherwise returns the value of <clix:ref>REMOTE-ADDR</clix:ref> as the only value.
    </clix:description>
  </clix:function>

  <clix:function name='parameter'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>string
  </clix:returns>
    <clix:description>Returns the GET or the POST parameter with
name <clix:arg>name</clix:arg> (a string) - or <code>NIL</code> if
there is none.  If both a GET and a POST parameter with the same name
exist the GET parameter is returned.  Search is case-sensitive.
    </clix:description>
  </clix:function>

  <clix:function name='get-parameter'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>string
  </clix:returns>
    <clix:description>Returns the GET parameter with name <clix:arg>name</clix:arg> (a string) - or <code>NIL</code> if
there is none.  Search is case-sensitive.
    </clix:description>
  </clix:function>

  <clix:function name='post-parameter'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>string
  </clix:returns>
    <clix:description>Returns the POST parameter with name <clix:arg>name</clix:arg> (a string) - or <code>NIL</code> if
there is none.  Search is case-sensitive.
    </clix:description>
  </clix:function>

  <clix:function name='get-parameters*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>alist
  </clix:returns>
    <clix:description>Returns an alist of the GET parameters associated with the <clix:ref>REQUEST</clix:ref>
object <clix:arg>request</clix:arg>.
    </clix:description>
  </clix:function>

  <clix:function name='post-parameters*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>alist
  </clix:returns>
    <clix:description>Returns an alist of the POST parameters associated with the <clix:ref>REQUEST</clix:ref>
object <clix:arg>request</clix:arg>.
    </clix:description>
  </clix:function>

  <clix:function name='cookie-in'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>cookie
  </clix:returns>
    <clix:description>Returns the cookie with the name <clix:arg>name</clix:arg> (a string) as sent by the
browser - or <code>NIL</code> if there is none.
    </clix:description>
  </clix:function>

  <clix:function name='cookies-in*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>alist
  </clix:returns>
    <clix:description>Returns an alist of all cookies associated with the <clix:ref>REQUEST</clix:ref> object
<clix:arg>request</clix:arg>.
    </clix:description>
  </clix:function>

  <clix:function name='query-string*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>string
  </clix:returns>
    <clix:description>Returns the query string of the <clix:ref>REQUEST</clix:ref> object <clix:arg>request</clix:arg>. That&#039;s
the part behind the question mark (i.e. the GET parameters).
    </clix:description>
  </clix:function>

  <clix:function name='request-method*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>keyword
  </clix:returns>
    <clix:description>Returns the request method as a Lisp keyword.
    </clix:description>
  </clix:function>

  <clix:function name='request-uri*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>uri
  </clix:returns>
    <clix:description>Returns the request URI.
    </clix:description>
  </clix:function>

  <clix:function name='server-protocol*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>keyword
  </clix:returns>
    <clix:description>Returns the request protocol as a Lisp keyword.
    </clix:description>
  </clix:function>

  <clix:function name='headers-in*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>alist
  </clix:returns>
    <clix:description>Returns an alist of the incoming headers associated with the
<clix:ref>REQUEST</clix:ref> object <clix:arg>request</clix:arg>.
    </clix:description>
  </clix:function>

  <clix:function name='remote-addr*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>address
  </clix:returns>
    <clix:description>Returns the address the current request originated from.
    </clix:description>
  </clix:function>

  <clix:function name='remote-port*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>port
  </clix:returns>
    <clix:description>Returns the port the current request originated from.
    </clix:description>
  </clix:function>

  <clix:accessor name='aux-request-value'>
  <clix:lambda-list>symbol 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>value, present-p
  </clix:returns>
    <clix:description>This accessor can be used to associate arbitrary
    data with the the symbol <clix:arg>symbol</clix:arg> in the <clix:ref>REQUEST</clix:ref> object
    <clix:arg>request</clix:arg>. <clix:arg>present-p</clix:arg> is true if such data was found, otherwise <code>NIL</code>.
    </clix:description>
  </clix:accessor>

  <clix:function name='delete-aux-request-value'>
  <clix:lambda-list>symbol 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Removes the value associated with <clix:arg>symbol</clix:arg> from the <clix:ref>REQUEST</clix:ref> object
<clix:arg>request</clix:arg>.
    </clix:description>
  </clix:function>


  <clix:readers generic='true'>
    <clix:listed-reader name='cookies-in'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>cookies
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='get-parameters'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>get-parameters
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='headers-in'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>headers
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='post-parameters'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>post-parameters
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='query-string'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>query-string
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='remote-addr'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>address
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='remote-port'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>port
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='request-acceptor'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>acceptor
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='request-method'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>method
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='request-uri'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>uri
    </clix:returns>
    </clix:listed-reader>

    <clix:listed-reader name='server-protocol'>
    <clix:lambda-list>request
    </clix:lambda-list>
    <clix:returns>protocol
    </clix:returns>
    </clix:listed-reader>

    <clix:description>These are various generic readers which are used
    to read information about a <clix:ref>REQUEST</clix:ref> object.  If you are writing a
    <a href="#handlers">handler</a>, you should <em>not</em> use these readers but instead utilize the
    corresponding functions with an asterisk at the end of their name,
    also listed in this section.  These generic readers are only
    exported for users who want to create their own subclasses of
    <clix:ref>REQUEST</clix:ref>.
    </clix:description>

  </clix:readers>

    </clix:subchapter>

    <clix:subchapter name="replies" title="Reply objects">
    </clix:subchapter>

    <clix:subchapter name="sessions" title="Sessions">
Hunchentoot supports sessions: Once a <a href="#handlers">request
handler</a> has called <clix:ref>START-SESSION</clix:ref>, Hunchentoot
uses either cookies or (if the client doesn't send the cookies
back) <a href="#*rewrite-for-session-urls*">rewrites URLs</a> to keep
track of this client, i.e. to provide a kind of 'state' for the
stateless http protocol. The session associated with the client is an
opaque CLOS object which can be used to <a href="#session-value">store
arbitrary data</a> between requests.
<p>
Hunchentoot makes some reasonable effort to prevent eavesdroppers from
hijacking sessions (see below), but this should not be considered
really secure. Don't store sensitive data in sessions and rely solely
on the session mechanism as a safeguard against malicious users who
want to get at this data!
</p>
<p>
For each request there's one SESSION object which is accessible to the
handler via the special variable *SESSION*. This object holds all the
information available about the session and can be accessed with the
functions described in this chapter. Note that the internal structure
of SESSION objects should be considered opaque and may change in
future releases of Hunchentoot.
</p>
<p>
Sessions are automatically <a href="#session-verify">verified</a> for
validity and age when the <clix:ref>REQUEST</clix:ref> object is
instantiated, i.e. if <clix:ref>*SESSION*</clix:ref> is not NIL then
this session is valid (as far as Hunchentoot is concerned) and
not <a href="#session-too-old-p">too old</a>.  Old sessions
are <a href="#session-gc">automatically removed</a>.
</p>
<p>
For everyday session usage, you will probably just
use <clix:ref>START-SESSION</clix:ref>,
<clix:ref>SESSION-VALUE</clix:ref>,
maybe <clix:ref>DELETE-SESSION-VALUE</clix:ref>
and <clix:ref>*SESSION*</clix:ref>.  However, there are two ways to
customize the way Hunchentoot maintains sessions:
</p>
<p>
</p>

  <clix:class name='session'>
    <clix:description><clix:ref>SESSION</clix:ref> objects are
automatically maintained by Hunchentoot.  They should not be created
explicitly with <code>MAKE-INSTANCE</code> but implicitly
with <clix:ref>START-SESSION</clix:ref> and they should be treated as
opaque objects.
<p>
You can ignore Hunchentoot's <clix:ref>SESSION</clix:ref> objects and
implement your own sessions if you provide corresponding methods for
<clix:ref>SESSION-COOKIE-VALUE</clix:ref>
and <clix:ref>SESSION-VERIFY</clix:ref>.
</p>
    </clix:description>
  </clix:class>

  <clix:function name='start-session'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>session
  </clix:returns>
    <clix:description>Returns the current <clix:ref>SESSION</clix:ref>
object. If there is no current session, creates one and updates the
corresponding data structures. In this case the function will also
send a session cookie to the browser.
    </clix:description>
  </clix:function>

  <clix:accessor name='session-value'>
  <clix:lambda-list>symbol 
  <clix:lkw>optional
  </clix:lkw> session
  </clix:lambda-list>
  <clix:returns>value, present-p
  </clix:returns>
    <clix:description>
This accessor can be used to associate arbitrary data with the the
symbol <clix:arg>symbol</clix:arg> in the <clix:ref>SESSION</clix:ref>
object <clix:arg>session</clix:arg>. <clix:arg>present-p</clix:arg> is
true if such data was found, otherwise <code>NIL</code>. The default
value for <clix:arg>session</clix:arg> is
<clix:ref>*SESSION*</clix:ref>.
<p>
If <code>SETF</code> of <clix:ref>SESSION-VALUE</clix:ref> is called
with <clix:arg>session</clix:arg> being <code>NIL</code> then a
session is automatically instantiated
with <clix:ref>START-SESSION</clix:ref>.
</p>
    </clix:description>
  </clix:accessor>

  <clix:function name='delete-session-value'>
  <clix:lambda-list>symbol 
  <clix:lkw>optional
  </clix:lkw> session
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Removes the value associated
with <clix:arg>symbol</clix:arg> from <clix:arg>session</clix:arg> if
there is one.
    </clix:description>
  </clix:function>



  <clix:special-variable name='*session*'>
    <clix:description>The current SESSION object in the context of a
    request, or <code>NIL</code>.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*rewrite-for-session-urls*'>
    <clix:description>Whether HTML pages should possibly be rewritten for cookie-less
session-management.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*content-types-for-url-rewrite*'>
    <clix:description>The content types for which url-rewriting is
    OK. See
<clix:ref>*REWRITE-FOR-SESSION-URLS*</clix:ref>.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*session-gc-frequency*'>
    <clix:description>A session GC (see function <clix:ref>SESSION-GC</clix:ref>) will happen every
<clix:ref>*SESSION-GC-FREQUENCY*</clix:ref> requests (counting only
requests which create a new session) if this variable is
not <code>NIL</code>.  See <clix:ref>SESSION-CREATED</clix:ref>.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*session-max-time*'>
    <clix:description>The default time (in seconds) after which a session times out.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*session-removal-hook*'>
    <clix:description>A function of one argument
(a <clix:ref>SESSION</clix:ref> object) which is called whenever a
session is <a href="#session-gc">garbage-collected</a>.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*session-secret*'>
    <clix:description>A random ASCII string that&#039;s used to encode
the public session data.  This variable is initially unbound and will
be set (using <clix:ref>RESET-SESSION-SECRET</clix:ref>) the first
time a session is created, if necessary.  You can prevent this from
happening if you set the value yourself before
starting <a href="#acceptors">acceptors</a>.
    </clix:description>
  </clix:special-variable>



  <clix:special-variable name='*use-remote-addr-for-sessions*'>
    <clix:description>Whether the client&#039;s remote IP (as returned by <clix:ref>REAL-REMOTE-ADDR</clix:ref>)
should be encoded into the session string.  If this value is true, a
session will cease to be accessible if the client&#039;s remote IP changes.
<p>
This might for example be an issue if the client uses a proxy server
which doesn&#039;t send correct &#039;X_FORWARDED_FOR&#039; headers.
</p>
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*use-user-agent-for-sessions*'>
    <clix:description>Whether the &#039;User-Agent&#039; header should be encoded into the session
string.  If this value is true, a session will cease to be accessible
if the client sends a different &#039;User-Agent&#039; header.
    </clix:description>
  </clix:special-variable>


  <clix:function generic='true' name='next-session-id'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>id
  </clix:returns>
    <clix:description>Returns the next sequential session ID, an
integer, which should be unique per session.  The default method uses
a simple global counter and isn&#039;t guarded by a lock.  For a
high-performance production environment you might consider to use a
more robust implementation.
    </clix:description>
  </clix:function>


  <clix:function name='remove-session'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Completely removes the SESSION object SESSION from Hunchentoot&#039;s
internal session database.
    </clix:description>
  </clix:function>

  <clix:function name='reset-session-secret'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>secret
  </clix:returns>
    <clix:description>Sets *SESSION-SECRET* to a new random value. All old sessions will
cease to be valid.
    </clix:description>
  </clix:function>

  <clix:function name='reset-sessions'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Removes ALL stored sessions.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='session-cookie-name'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>name
  </clix:returns>
    <clix:description>Returns the name (a string) of the cookie (or the
GET parameter) which is used to store a session on the client side.
The default is to use the string &quot;hunchentoot-session&quot;, but you can
specialize this function if you want another name.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='session-cookie-value'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>string
  </clix:returns>
    <clix:description>Returns a string which can be used to safely
restore the session SESSION if as session has already been
established.  This is used as the value stored in the session cookie
or in the corresponding GET parameter.  A default method is provided
and there&#039;s no reason to change it unless you want to use your own
session objects.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='session-created'>
  <clix:lambda-list>acceptor new-session
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>This function is called whenever a new session has
been created.  There&#039;s a default method which might trigger a session
GC based on the value of *SESSION-GC-FREQUENCY*.
<p>
The return value is ignored.
</p>
    </clix:description>
  </clix:function>

  <clix:accessor generic='true' name='session-db'>
  <clix:lambda-list>acceptor
  </clix:lambda-list>
  <clix:returns>database
  </clix:returns>
    <clix:description>Returns the current session database which is an
alist where each car is a session&#039;s ID and the cdr is the
corresponding SESSION object itself.  The default is to use a global
list for all acceptors.
    </clix:description>
  </clix:accessor>

  <clix:function generic='true' name='session-db-lock'>
  <clix:lambda-list>acceptor 
  <clix:lkw>key
  </clix:lkw> whole-db-p
  </clix:lambda-list>
  <clix:returns>lock
  </clix:returns>
    <clix:description>A function which returns a lock that will be used
to prevent concurrent access to sessions.  The first argument will be
the acceptor that handles the current request, the second argument is
true if the whole (current) session database is modified.  If it is
NIL, only one existing session in the database is modified.

This function can return NIL which means that sessions or session
databases will be modified without a lock held (for example for
single-threaded environments).  The default is to always return a
global lock (ignoring the ACCEPTOR argument) for Lisps that support
threads and NIL otherwise.
    </clix:description>
  </clix:function>

  <clix:function name='session-gc'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>|
  </clix:returns>
    <clix:description>Removes sessions from the current session database which are too
old - see SESSION-TOO-OLD-P.
    </clix:description>
  </clix:function>

  <clix:accessor generic='true' name='session-max-time'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>max-time
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>

  <clix:function generic='true' name='session-remote-addr'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>remote-addr
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>

  <clix:function name='session-too-old-p'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>generalized-boolean
  </clix:returns>
    <clix:description>Returns true if the SESSION object SESSION has not been active in
the last (SESSION-MAX-TIME SESSION) seconds.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='session-user-agent'>
  <clix:lambda-list>session
  </clix:lambda-list>
  <clix:returns>user-agent
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='session-verify'>
  <clix:lambda-list>request
  </clix:lambda-list>
  <clix:returns>session-or-nil
  </clix:returns>
    <clix:description>Tries to get a session identifier from the cookies
(or alternatively from the GET parameters) sent by the client.  This
identifier is then checked for validity against the REQUEST object
REQUEST.  On success the corresponding session object (if not too
old) is returned (and updated).  Otherwise NIL is returned.

A default method is provided and you only need to write your own one
if you want to maintain your own sessions.
    </clix:description>
  </clix:function>


    </clix:subchapter>

    <clix:subchapter name="handlers" title="Handlers">
    </clix:subchapter>

    <clix:subchapter name="handler-selection" title="Handler selection">
    </clix:subchapter>

    <clix:subchapter name="logging" title="Logging">

By default, Hunchentoot logs accesses and errors to two separate files
in the file system, but <em>only</em> if the special variables
<clix:ref>*MESSAGE-LOG-PATHNAME*</clix:ref> and <clix:ref>*ACCESS-LOG-PATHNAME*</clix:ref> are set accordingly.
Access logging is done in a format similar to what
the Apache web server can write so that logfile analysis using
standard tools is possible.  Errors during request processing are
logged to a separate file.
<p>
The standard logging mechanism is deliberately simple and slow.  The
log files are opened for each log entry and closed again after
writing, and access to them is protected by a global lock.  If you
want more sophisticated logging, use
the <a href="#acceptor-access-logger"><code>:access-logger</code></a>
and <a href="#acceptor-message-logger"><code>:message-logger</code></a>
initargs of the acceptor class to establish your own logging
functions.  See the docstrings of the corresponding slots for more
information.
</p>
<p>
Errors happening within a <a href="#handlers">handler</a> which are
not caught by the handler itself are handled by Hunchentoot by logging
them to the log file.
</p>

  <clix:function name='log-message'>
  <clix:lambda-list>log-level format-string 
  <clix:lkw>rest
  </clix:lkw> format-arguments
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Convenience function which calls the message
logger of the current acceptor (if there is one) with the same
arguments it accepts.  Returns <code>NIL</code> if there is no message
logger or whatever the message logger returns.
<p>
This is the function which Hunchentoot itself uses to log errors it
catches during request processing.
</p>
    </clix:description>
  </clix:function>

  <clix:special-variable name='*message-log-pathname*'>
    <clix:description>
A designator for the pathname of the message log file used by the
<a href="#logging">default message logger</a>.  The initial value is <code>NIL</code> which
means that <em>nothing</em> will be logged!
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*access-log-pathname*'>
    <clix:description>
A designator for the pathname of the access log file used by the
<a href="#logging">default access logger</a>.  The initial value is <code>NIL</code> which
means that <em>nothing</em> will be logged!
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*log-lisp-errors-p*'>
    <clix:description>Whether Lisp errors in request handlers should be logged.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*log-lisp-warnings-p*'>
    <clix:description>Whether Lisp warnings in request handlers should be logged.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*lisp-errors-log-level*'>
    <clix:description>Log level for Lisp errors.  Should be one
of <code>:ERROR</code> (the default), <code>:WARNING</code>,
or <code>:INFO</code>.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*lisp-warnings-log-level*'>
    <clix:description>Log level for Lisp warnings.
Should be one of <code>:ERROR</code>, <code>:WARNING</code>
(the default), or <code>:INFO</code>.
    </clix:description>
  </clix:special-variable>


    </clix:subchapter>

    <clix:subchapter name="conditions" title="Conditions">
    </clix:subchapter>

    <clix:subchapter name="misc" title="Miscellaneous">
    </clix:subchapter>

  </clix:chapter>

    <clix:chapter name='dict' title='The HUNCHENTOOT dictionary'>

  <clix:special-variable name='*approved-return-codes*'>
    <clix:description>A list of return codes the server should not treat as an error -
see *HANDLE-HTTP-ERRORS-P*.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*cleanup-function*'>
    <clix:description>A designator for a function without arguments which is called on a
regular basis if *CLEANUP-INTERVAL* is not NIL.  The initial value is
the name of a function which invokes a garbage collection on 32-bit
versions of LispWorks.

This variable is only available on LispWorks.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*cleanup-interval*'>
    <clix:description>Should be NIL or a positive integer.  The system calls
*CLEANUP-FUNCTION* whenever *CLEANUP-INTERVAL* new worker threads
(counted globally across all acceptors) have been created unless the
value is NIL.  The initial value is 100.

This variable is only available on LispWorks.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*default-content-type*'>
    <clix:description>The default content-type header which is returned to the client.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*default-handler*'>
    <clix:description>The name of the function which is always returned by
DEFAULT-DISPATCHER.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*dispatch-table*'>
    <clix:description>A global list of dispatch functions.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*file-upload-hook*'>
    <clix:description>If this is not NIL, it should be a unary function which will
be called with a pathname for each file which is uploaded to
Hunchentoot.  The pathname denotes the temporary file to which
the uploaded file is written.  The hook is called directly before
the file is created.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*handle-http-errors-p*'>
    <clix:description>A generalized boolean that determines whether return codes which
are not in *APPROVED-HEADERS* are treated specially.  When its value
is true (the default), either a default body for the return code or
the result of calling *HTTP-ERROR-HANDLER* is used.  When the value is
NIL, no special action is taken and you are expected to supply your
own response body to describe the error.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*header-stream*'>
    <clix:description>If this variable is not NIL, it should be bound to a stream to
which incoming and outgoing headers will be written for debugging
purposes.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*http-error-handler*'>
    <clix:description>Contains NIL (the default) or a function of one argument which is
called if the content handler has set a return code which is not in
*APPROVED-RETURN-CODES* and *HANDLE-HTTP-ERRORS* is true.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*hunchentoot-default-external-format*'>
    <clix:description>The external format used to compute the REQUEST object.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*methods-for-post-parameters*'>
    <clix:description>A list of the request method types (as keywords) for which
Hunchentoot will try to compute POST-PARAMETERS.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*reply*'>
    <clix:description>The current REPLY object.
    </clix:description>
  </clix:special-variable>

  <clix:special-variable name='*show-lisp-errors-p*'>
    <clix:description>Whether Lisp errors should be shown in HTML output.
    </clix:description>
  </clix:special-variable>
  <clix:special-variable name='*tmp-directory*'>
    <clix:description>Directory for temporary files created by MAKE-TMP-FILE-NAME.
    </clix:description>
  </clix:special-variable>

  <clix:constant name='+http-accepted+'>
    <clix:description>HTTP return code (202) for &#039;Accepted&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-authorization-required+'>
    <clix:description>HTTP return code (401) for &#039;Authorization Required&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-bad-gateway+'>
    <clix:description>HTTP return code (502) for &#039;Bad Gateway&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-bad-request+'>
    <clix:description>HTTP return code (400) for &#039;Bad Request&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-conflict+'>
    <clix:description>HTTP return code (409) for &#039;Conflict&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-continue+'>
    <clix:description>HTTP return code (100) for &#039;Continue&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-created+'>
    <clix:description>HTTP return code (201) for &#039;Created&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-expectation-failed+'>
    <clix:description>HTTP return code (417) for &#039;Expectation Failed&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-failed-dependency+'>
    <clix:description>HTTP return code (424) for &#039;Failed Dependency&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-forbidden+'>
    <clix:description>HTTP return code (403) for &#039;Forbidden&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-gateway-time-out+'>
    <clix:description>HTTP return code (504) for &#039;Gateway Time-out&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-gone+'>
    <clix:description>HTTP return code (410) for &#039;Gone&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-internal-server-error+'>
    <clix:description>HTTP return code (500) for &#039;Internal Server Error&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-length-required+'>
    <clix:description>HTTP return code (411) for &#039;Length Required&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-method-not-allowed+'>
    <clix:description>HTTP return code (405) for &#039;Method Not Allowed&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-moved-permanently+'>
    <clix:description>HTTP return code (301) for &#039;Moved Permanently&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-moved-temporarily+'>
    <clix:description>HTTP return code (302) for &#039;Moved Temporarily&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-multi-status+'>
    <clix:description>HTTP return code (207) for &#039;Multi-Status&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-multiple-choices+'>
    <clix:description>HTTP return code (300) for &#039;Multiple Choices&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-no-content+'>
    <clix:description>HTTP return code (204) for &#039;No Content&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-non-authoritative-information+'>
    <clix:description>HTTP return code (203) for &#039;Non-Authoritative Information&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-not-acceptable+'>
    <clix:description>HTTP return code (406) for &#039;Not Acceptable&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-not-found+'>
    <clix:description>HTTP return code (404) for &#039;Not Found&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-not-implemented+'>
    <clix:description>HTTP return code (501) for &#039;Not Implemented&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-not-modified+'>
    <clix:description>HTTP return code (304) for &#039;Not Modified&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-ok+'>
    <clix:description>HTTP return code (200) for &#039;OK&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-partial-content+'>
    <clix:description>HTTP return code (206) for &#039;Partial Content&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-payment-required+'>
    <clix:description>HTTP return code (402) for &#039;Payment Required&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-precondition-failed+'>
    <clix:description>HTTP return code (412) for &#039;Precondition Failed&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-proxy-authentication-required+'>
    <clix:description>HTTP return code (407) for &#039;Proxy Authentication Required&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-request-entity-too-large+'>
    <clix:description>HTTP return code (413) for &#039;Request Entity Too Large&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-request-time-out+'>
    <clix:description>HTTP return code (408) for &#039;Request Time-out&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-request-uri-too-large+'>
    <clix:description>HTTP return code (414) for &#039;Request-URI Too Large&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-requested-range-not-satisfiable+'>
    <clix:description>HTTP return code (416) for &#039;Requested range not satisfiable&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-reset-content+'>
    <clix:description>HTTP return code (205) for &#039;Reset Content&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-see-other+'>
    <clix:description>HTTP return code (303) for &#039;See Other&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-service-unavailable+'>
    <clix:description>HTTP return code (503) for &#039;Service Unavailable&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-switching-protocols+'>
    <clix:description>HTTP return code (101) for &#039;Switching Protocols&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-temporary-redirect+'>
    <clix:description>HTTP return code (307) for &#039;Temporary Redirect&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-unsupported-media-type+'>
    <clix:description>HTTP return code (415) for &#039;Unsupported Media Type&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-use-proxy+'>
    <clix:description>HTTP return code (305) for &#039;Use Proxy&#039;.
    </clix:description>
  </clix:constant>
  <clix:constant name='+http-version-not-supported+'>
    <clix:description>HTTP return code (505) for &#039;Version not supported&#039;.
    </clix:description>
  </clix:constant>
  <clix:function name='abort-request-handler'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> result
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>This function can be called by a request handler at any time to
immediately abort handling the request.  This works as if the handler
had returned RESULT.  See the source code of REDIRECT for an example.
    </clix:description>
  </clix:function>
  <clix:function name='authorization'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns as two values the user and password (if any) as encoded in
the &#039;AUTHORIZATION&#039; header.  Returns NIL if there is no such header.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='content-length'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(REPLY)' name='content-length'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:accessor name='content-length*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>The outgoing &#039;Content-Length&#039; http header of REPLY.
    </clix:description>
  </clix:accessor>
  <clix:function generic='true' name='content-type'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(REPLY)' name='content-type'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:accessor name='content-type*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>The outgoing &#039;Content-Type&#039; http header of REPLY.
    </clix:description>
  </clix:accessor>
  <clix:accessor generic='true' name='cookie-domain'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-domain'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor generic='true' name='cookie-expires'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-expires'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor generic='true' name='cookie-http-only'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-http-only'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:function generic='true' name='cookie-name'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(COOKIE)' name='cookie-name'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function name='cookie-out'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the current value of the outgoing cookie named
NAME. Search is case-sensitive.
    </clix:description>
  </clix:function>
  <clix:accessor generic='true' name='cookie-path'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-path'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor generic='true' name='cookie-secure'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-secure'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor generic='true' name='cookie-value'>
  <clix:lambda-list>cookie
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(COOKIE)' name='cookie-value'>
  <clix:lambda-list>(cookie cookie)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>

  <clix:accessor generic='true' name='cookies-out'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(REPLY)' name='cookies-out'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor name='cookies-out*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns an alist of the outgoing cookies associated with the
REPLY object REPLY.
    </clix:description>
  </clix:accessor>
  <clix:function name='create-folder-dispatcher-and-handler'>
  <clix:lambda-list>uri-prefix base-path 
  <clix:lkw>optional
  </clix:lkw> content-type
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Creates and returns a dispatch function which will dispatch to a
handler function which emits the file relative to BASE-PATH that is
denoted by the URI of the request relative to URI-PREFIX.  URI-PREFIX
must be a string ending with a slash, BASE-PATH must be a pathname
designator for an existing directory.  If CONTENT-TYPE is not NIL,
it&#039;ll be the content type used for all files in the folder.
    </clix:description>
  </clix:function>
  <clix:function name='create-prefix-dispatcher'>
  <clix:lambda-list>prefix handler
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Creates a request dispatch function which will dispatch to the
function denoted by HANDLER if the file name of the current request
starts with the string PREFIX.
    </clix:description>
  </clix:function>
  <clix:function name='create-regex-dispatcher'>
  <clix:lambda-list>regex handler
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Creates a request dispatch function which will dispatch to the
function denoted by HANDLER if the file name of the current request
matches the CL-PPCRE regular expression REGEX.
    </clix:description>
  </clix:function>
  <clix:function name='create-static-file-dispatcher-and-handler'>
  <clix:lambda-list>uri path 
  <clix:lkw>optional
  </clix:lkw> content-type
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Creates and returns a request dispatch function which will dispatch
to a handler function which emits the file denoted by the pathname
designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of
the request matches the string URI.  If CONTENT-TYPE is NIL, tries to
determine the content type via the file&#039;s suffix.
    </clix:description>
  </clix:function>
  <clix:function name='default-dispatcher'>
  <clix:lambda-list>request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Default dispatch function which handles every request with the
function stored in *DEFAULT-HANDLER*.
    </clix:description>
  </clix:function>
  <clix:function macro='true' name='define-easy-handler'>
  <clix:lambda-list>description lambda-list declaration* statement*
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Defines a handler with the body BODY and optionally registers
it with a URI so that it will be found by DISPATCH-EASY-HANDLERS.
DESCRIPTION is either a symbol NAME or a list matching the
destructuring lambda list

  (name &amp;key uri acceptor-names default-parameter-type default-request-type).

LAMBDA-LIST is a list the elements of which are either a symbol
VAR or a list matching the destructuring lambda list

  (var &amp;key real-name parameter-type init-form request-type).

The resulting handler will be a Lisp function with the name NAME
and keyword parameters named by the VAR symbols.  Each VAR will
be bound to the value of the GET or POST parameter called
REAL-NAME (a string) before BODY is executed.  If REAL-NAME is
not provided, it will be computed by downcasing the symbol name
of VAR.

If URI (which is evaluated) is provided, then it must be a string or
a function designator for a function of one argument.  In this case,
the handler will be returned by DISPATCH-EASY-HANDLERS, if URI is a
string and the script name of a request is URI, or if URI designates a
function and applying this function to the current request object
returns a true value.

ACCEPTOR-NAMES (which is evaluated) can be a list of symbols which
means that the handler will be returned by DISPATCH-EASY-HANDLERS in
acceptor which have one of these names (see ACCEPTOR-NAME).
ACCEPTOR-NAMES can also be the symbol T which means that the handler
will be returned by DISPATCH-EASY-HANDLERS in every acceptor.

Whether the GET or POST parameter (or both) will be taken into
consideration, depends on REQUEST-TYPE which can
be :GET, :POST, :BOTH, or NIL.  In the last case, the value of
DEFAULT-REQUEST-TYPE (the default of which is :BOTH) will be
used.

The value of VAR will usually be a string (unless it resulted from a
file upload in which case it won&#039;t be converted at all), but if
PARAMETER-TYPE (which is evaluated) is provided, the string will be
converted to another Lisp type by the following rules:

If the corresponding GET or POST parameter wasn&#039;t provided by the
client, VAR&#039;s value will be NIL.  If PARAMETER-TYPE is &#039;STRING, VAR&#039;s
value remains as is.  If PARAMETER-TYPE is &#039;INTEGER and the parameter
string consists solely of decimal digits, VAR&#039;s value will be the
corresponding integer, otherwise NIL.  If PARAMETER-TYPE is &#039;KEYWORD,
VAR&#039;s value will be the keyword obtained by interning the upcased
parameter string into the keyword package.  If PARAMETER-TYPE is
&#039;CHARACTER and the parameter string is of length one, VAR&#039;s value will
be the single character of this string, otherwise NIL.  If
PARAMETER-TYPE is &#039;BOOLEAN, VAR&#039;s value will always be T (unless it
is NIL by the first rule above, of course).  If PARAMETER-TYPE is any
other atom, it is supposed to be a function designator for a unary
function which will be called to convert the string to something else.

Those were the rules for `simple&#039; types, but PARAMETER-TYPE can
also be a list starting with one of the symbols LIST, ARRAY, or
HASH-TABLE.  The second value of the list must always be a simple
parameter type as in the last paragraph - we&#039;ll call it the
`inner type&#039; below.

In the case of &#039;LIST, all GET/POST parameters called REAL-NAME
will be collected, converted to the inner type, and assembled
into a list which will be the value of VAR.

In the case of &#039;ARRAY, all GET/POST parameters which have a name
like the result of

  (format nil &quot;~A[~A]&quot; real-name n)

where N is a non-negative integer, will be assembled into an
array where the Nth element will be set accordingly, after
conversion to the inner type.  The array, which will become the
value of VAR, will be big enough to hold all matching parameters,
but not bigger.  Array elements not set as described above will
be NIL.  Note that VAR will always be bound to an array, which
may be empty, so it will never be NIL, even if no appropriate
GET/POST parameters are found.

The full form of a &#039;HASH-TABLE parameter type is

  (hash-table inner-type key-type test-function),

but KEY-TYPE and TEST-FUNCTION can be left out in which case they
default to &#039;STRING and &#039;EQUAL, respectively.  For this parameter
type, all GET/POST parameters which have a name like the result
of

  (format nil &quot;~A{~A}&quot; real-name key)

(where KEY is a string that doesn&#039;t contain curly brackets) will
become the values (after conversion to INNER-TYPE) of a hash
table with test function TEST-FUNCTION where KEY (after
conversion to KEY-TYPE) will be the corresponding key.  Note that
VAR will always be bound to a hash table, which may be empty, so
it will never be NIL, even if no appropriate GET/POST parameters
are found.

To make matters even more complicated, the three compound
parameter types also have an abbreviated form - just one of the
symbols LIST, ARRAY, or HASH-TABLE.  In this case, the inner type
will default to &#039;STRING.

If PARAMETER-TYPE is not provided or NIL, DEFAULT-PARAMETER-TYPE
(the default of which is &#039;STRING) will be used instead.

If the result of the computations above would be that VAR would
be bound to NIL, then INIT-FORM (if provided) will be evaluated
instead, and VAR will be bound to the result of this evaluation.

Handlers built with this macro are constructed in such a way that
the resulting Lisp function is useful even outside of
Hunchentoot.  Specifically, all the parameter computations above
will only happen if *REQUEST* is bound, i.e. if we&#039;re within a
Hunchentoot request.  Otherwise, VAR will always be bound to the
result of evaluating INIT-FORM unless a corresponding keyword
argument is provided.
    </clix:description>
  </clix:function>

  <clix:function name='dispatch-easy-handlers'>
  <clix:lambda-list>request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>This is a dispatcher which returns the appropriate handler
defined with DEFINE-EASY-HANDLER, if there is one.
    </clix:description>
  </clix:function>
  <clix:function name='escape-for-html'>
  <clix:lambda-list>string
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Escapes the characters #\&lt;, #\&gt;, #\&#039;, #\&quot;, and #\&amp; for HTML output.
    </clix:description>
  </clix:function>

  <clix:function name='handle-if-modified-since'>
  <clix:lambda-list>time 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Handles the &#039;If-Modified-Since&#039; header of REQUEST.  The date string
is compared to the one generated from the supplied universal time
TIME.
    </clix:description>
  </clix:function>

  <clix:function name='handle-static-file'>
  <clix:lambda-list>path 
  <clix:lkw>optional
  </clix:lkw> content-type
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>A function which acts like a Hunchentoot handler for the file
denoted by PATH.  Sends a content type header corresponding to
CONTENT-TYPE or (if that is NIL) tries to determine the content type
via the file&#039;s suffix.
    </clix:description>
  </clix:function>
  <clix:function generic='true' name='header-in'>
  <clix:lambda-list>name request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(T T)' name='header-in'>
  <clix:lambda-list>name request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function name='header-in*'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the incoming header with name NAME.  NAME can be a keyword
(recommended) or a string.
    </clix:description>
  </clix:function>
  <clix:function name='header-out'>
  <clix:lambda-list>name 
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the current value of the outgoing http header named NAME.
NAME should be a keyword or a string.
    </clix:description>
  </clix:function>

  <clix:function generic='true' name='headers-out'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(REPLY)' name='headers-out'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function name='headers-out*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns an alist of the outgoing headers associated with the
REPLY object REPLY.
    </clix:description>
  </clix:function>
  <clix:function name='host'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the &#039;Host&#039; incoming http header value.
    </clix:description>
  </clix:function>
  <clix:function name='http-token-p'>
  <clix:lambda-list>token
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Tests whether TOKEN is a string which is a valid &#039;token&#039;
according to HTTP/1.1 (RFC 2068).
    </clix:description>
  </clix:function>
  <clix:condition name='hunchentoot-condition'>
    <clix:description>Superclass for all conditions related to Hunchentoot.
    </clix:description>
  </clix:condition>
  <clix:condition name='hunchentoot-error'>
    <clix:description>Superclass for all errors related to Hunchentoot.
    </clix:description>
  </clix:condition>


  <clix:function name='mime-type'>
  <clix:lambda-list>pathspec
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Given a pathname designator PATHSPEC returns the MIME type
(as a string) corresponding to the suffix of the file denoted by
PATHSPEC (or NIL).
    </clix:description>
  </clix:function>

  <clix:function name='no-cache'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Adds appropriate headers to completely prevent caching on most browsers.
    </clix:description>
  </clix:function>

  <clix:function name='raw-post-data'>
  <clix:lambda-list>
  <clix:lkw>key
  </clix:lkw> request external-format force-text force-binary want-stream
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the content sent by the client if there was any (unless
the content type was &quot;multipart/form-data&quot;).  By default, the result
is a string if the type of the `Content-Type&#039; media type is &quot;text&quot;,
and a vector of octets otherwise.  In the case of a string, the
external format to be used to decode the content will be determined
from the `charset&#039; parameter sent by the client (or otherwise
*HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used).

You can also provide an external format explicitly (through
EXTERNAL-FORMAT) in which case the result will unconditionally be a
string.  Likewise, you can provide a true value for FORCE-TEXT which
will force Hunchentoot to act as if the type of the media type had
been &quot;text&quot;.  Or you can provide a true value for FORCE-BINARY which
means that you want a vector of octets at any rate.

If, however, you provide a true value for WANT-STREAM, the other
parameters are ignored and you&#039;ll get the content (flexi) stream to
read from it yourself.  It is then your responsibility to read the
correct amount of data, because otherwise you won&#039;t be able to return
a response to the client.  If the content type of the request was
`multipart/form-data&#039; or `application/x-www-form-urlencoded&#039;, the
content has been read by Hunchentoot already and you can&#039;t read from
the stream anymore.

You can call RAW-POST-DATA more than once per request, but you can&#039;t
mix calls which have different values for WANT-STREAM.

Note that this function is slightly misnamed because a client can send
content even if the request method is not POST.
    </clix:description>
  </clix:function>
 
  <clix:function name='reason-phrase'>
  <clix:lambda-list>return-code
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns a reason phrase for the HTTP return code RETURN-CODE
(which should be an integer) or NIL for return codes Hunchentoot
doesn&#039;t know.
    </clix:description>
  </clix:function>
  <clix:function name='recompute-request-parameters'>
  <clix:lambda-list>
  <clix:lkw>key
  </clix:lkw> request external-format
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Recomputes the GET and POST parameters for the REQUEST object
REQUEST.  This only makes sense if you&#039;re switching external formats
during the request.
    </clix:description>
  </clix:function>
  <clix:function name='redirect'>
  <clix:lambda-list>target 
  <clix:lkw>key
  </clix:lkw> host port protocol add-session-id code
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Redirects the browser to TARGET which should be a string.  If
TARGET is a full URL starting with a scheme, HOST, PORT and PROTOCOL
are ignored.  Otherwise, TARGET should denote the path part of a URL,
PROTOCOL must be one of the keywords :HTTP or :HTTPS, and the URL to
redirect to will be constructed from HOST, PORT, PROTOCOL, and TARGET.
Adds a session ID if ADD-SESSION-ID is true.  If CODE is a 3xx
redirection code, it will be sent as status code.
    </clix:description>
  </clix:function>
  <clix:function name='referer'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the &#039;Referer&#039; (sic!) http header.
    </clix:description>
  </clix:function>

  <clix:class name='reply'>
    <clix:description>Objects of this class hold all the information
about an outgoing reply.  They are created automatically by
Hunchentoot and can be accessed and modified by the corresponding
handler.

You should not mess with the slots of these objects directly, but you
can subclass REPLY in order to implement your own behaviour.  See the
REPLY-CLASS slot of the ACCEPTOR class.
    </clix:description>
  </clix:class>
  <clix:accessor generic='true' name='reply-external-format'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(REPLY)' name='reply-external-format'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor name='reply-external-format*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>The external format of REPLY which is used for character output.
    </clix:description>
  </clix:accessor>
  <clix:function name='require-authorization'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> realm
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Sends back appropriate headers to require basic HTTP authentication
(see RFC 2617) for the realm REALM.
    </clix:description>
  </clix:function>

  <clix:accessor generic='true' name='return-code'>
  <clix:lambda-list>reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor specialized='(REPLY)' name='return-code'>
  <clix:lambda-list>(reply reply)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:accessor>
  <clix:accessor name='return-code*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>The http return code of REPLY.  The return codes Hunchentoot can
handle are defined in specials.lisp.
    </clix:description>
  </clix:accessor>
  <clix:function name='rfc-1123-date'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> time
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Generates a time string according to RFC 1123.  Default is current time.
    </clix:description>
  </clix:function>
  <clix:function generic='true' name='script-name'>
  <clix:lambda-list>request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function specialized='(REQUEST)' name='script-name'>
  <clix:lambda-list>(request request)
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>
    </clix:description>
  </clix:function>
  <clix:function name='script-name*'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the file name of the REQUEST object REQUEST. That&#039;s the
requested URI without the query string (i.e the GET parameters).
    </clix:description>
  </clix:function>
  <clix:function name='send-headers'>
  <clix:lambda-list>
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Sends the initial status line and all headers as determined by the
REPLY object *REPLY*.  Returns a binary stream to which the body of
the reply can be written.  Once this function has been called, further
changes to *REPLY* don&#039;t have any effect.  Also, automatic handling of
errors (i.e. sending the corresponding status code to the browser,
etc.) is turned off for this request.  If your handlers return the
full body as a string or as an array of octets you should NOT call
this function.
    </clix:description>
  </clix:function>
  <clix:function name='set-cookie'>
  <clix:lambda-list>name 
  <clix:lkw>key
  </clix:lkw> value expires path domain secure http-only reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Creates a cookie object from the parameters provided and adds
it to the outgoing cookies of the REPLY object REPLY. If a cookie
with the name NAME (case-sensitive) already exists, it is
replaced.
    </clix:description>
  </clix:function>
  <clix:function name='set-cookie*'>
  <clix:lambda-list>cookie 
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Adds the COOKIE object COOKIE to the outgoing cookies of the
REPLY object REPLY. If a cookie with the same name
(case-sensitive) already exists, it is replaced.
    </clix:description>
  </clix:function>

  <clix:function name='ssl-p'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> acceptor
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Whether the current connection to the client is secure.
    </clix:description>
  </clix:function>

  <clix:function name='url-decode'>
  <clix:lambda-list>string 
  <clix:lkw>optional
  </clix:lkw> external-format
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Decodes a URL-encoded STRING which is assumed to be encoded using
the external format EXTERNAL-FORMAT.
    </clix:description>
  </clix:function>
  <clix:function name='url-encode'>
  <clix:lambda-list>string 
  <clix:lkw>optional
  </clix:lkw> external-format
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>URL-encodes a string using the external format EXTERNAL-FORMAT.
    </clix:description>
  </clix:function>
  <clix:function name='user-agent'>
  <clix:lambda-list>
  <clix:lkw>optional
  </clix:lkw> request
  </clix:lambda-list>
  <clix:returns>result
  </clix:returns>
    <clix:description>Returns the &#039;User-Agent&#039; http header.
    </clix:description>
  </clix:function>
  <clix:function generic='true' name='header-out'>
  <clix:lambda-list>new-value name 
  <clix:lkw>optional
  </clix:lkw> reply
  </clix:lambda-list>
    <clix:description>Changes the current value of the outgoing http
header named NAME (a keyword or a string).  If a header with this
name doesn&#039;t exist, it is created.
    </clix:description>
  </clix:function>


  <clix:function generic='true' name='process-request'>
  <clix:lambda-list>request
  </clix:lambda-list>
  <clix:returns>nil
  </clix:returns>
    <clix:description>
This function is called by <clix:ref>PROCESS-CONNECTION</clix:ref>
after the incoming headers have been read.  It selects and calls a
handler and sends the output of this handler to the client.  It also
sets up simple error handling for the request handler.  Note
that <clix:ref>PROCESS-CONNECTION</clix:ref> is called once per
connection and loops in case of a persistent connection
while <clix:ref>PROCESS-REQUEST</clix:ref> is called anew for each
request.
<p>
Like <clix:ref>PROCESS-CONNECTION</clix:ref>, this might be a good
place to introduce around methods which bind special variables or do
other interesting things.
</p>
<p>
The return value of this function is ignored.
</p>
    </clix:description>
  </clix:function>

    </clix:chapter>

  <clix:chapter name="testing" title="Testing">
    Hunchentoot comes with a test script which verifies that the
    example web server responds as expected.  This test script uses the
    <a href="http://weitz.de/drakma/">Drakma</a> HTTP client library
    and thus shares a significant amount of its base code with
    Hunchentoot itself.  Still, running the test script is a useful
    confidence test, and it is also possible to run the script across
    machines in order to verify a new Hunchentoot (or, for that matter
    Drakma) port.
    <p>
      To run the confidence test, <a href="#start">start
      the example web server</a>.  Then, in your Lisp
      listener, type
<pre>(<a class="noborder" href="hunchentoot-test:test-hunchentoot">hunchentoot-test:test-hunchentoot</a> "http://localhost:4242")</pre>
      You will see some diagnostic output and a summary line that
      reports whether any tests have failed.  (You can also use the
      example certificate and key files in the test directory and
      start and test an https server instead.)
    </p>

    <clix:function name="hunchentoot-test:test-hunchentoot">
      <clix:lambda-list>base-url <clix:lkw>key</clix:lkw></clix:lambda-list>
      <clix:returns>|</clix:returns>
      <clix:description>
        Runs the built-in confidence
        test.  <clix:arg>base-url</clix:arg> is the base URL to use
        for testing, it should not have a trailing slash.  The keyword
        arguments accepted are for future extension and should not
        currently be used.
        <p>
          The script expects the Hunchentoot example test server to be
          running at the given <clix:arg>base-url</clix:arg> and
          retrieves various pages from that server, expecting certain
          responses.
        </p>
      </clix:description>
    </clix:function>

  </clix:chapter>

  <clix:chapter name="history" title="History">

    Hunchentoot's predecessor <a href="http://weitz.de/tbnl/">TBNL</a>
    (which is short for "To Be Named Later") grew over the years as a
    toolkit that I used for various commercial and private
    projects. In August 2003, Daniel Barlow started
    a <a href="http://article.gmane.org/gmane.lisp.web/148">review of
      web APIs</a> on
    the <a href="http://www.red-bean.com/lispweb/">lispweb</a> mailing
    list and
    I <a href="http://article.gmane.org/gmane.lisp.web/153">described</a>
    the API of my hitherto-unreleased bunch of code (and christened it
    "TBNL").
    <p>
      It turned out that
      <a href="http://www.jeffcaldwell.com/">Jeff Caldwell</a> had
      worked on something similar so he emailed me and proposed to
      join our efforts. As I had no immediate plans to release my code
      (which was poorly organized, undocumented, and mostly
      CMUCL-specific), I gave it to Jeff and he worked towards a
      release. He added docstrings, refactored, added some stuff, and
      based it on KMRCL to make it portable across several Lisp
      implementations.
    </p>
    <p>
      Unfortunately, Jeff is at least as busy as I am so he didn't
      find the time to finish a full release.  But in spring 2004 I
      needed a documented version of the code for a client of mine who
      thought it would be good if the toolkit were publicly available
      under an open source license. So I took Jeff's code, refactored
      again (to sync with the changes I had done in the meantime), and
      added documentation.  This resulted in TBNL 0.1.0 (which
      initially required mod_lisp as its front-end).
    </p>
    <p>
      In March 2005, Bob Hutchinson sent patches which enabled TBNL to
      use other front-ends than mod_lisp.  This made me aware that
      TBNL was already <em>almost</em> a full web server, so
      eventually I wrote Hunchentoot which <em>was</em> a full web
      server, implemented as a wrapper around TBNL.  Hunchentoot 0.1.0
      was released at the end of 2005 and was originally
      LispWorks-only.
    </p>
    <p>
      Hunchentoot 0.4.0, released in October 2006, was the first
      release which also worked with other Common Lisp
      implementations.  It is a major rewrite and also incorporates
      most of TBNL and replaces it completely.
    </p>
    <p>
      Hunchentoot 1.0.0, released in February 2009, is again a major
      rewrite and should be considered work in progress.  It moved to
      using
      the <a href="http://common-lisp.net/project/usocket/">usocket</a>
      and <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a> libraries for non-LispWorks Lisps, thereby removing most of
      the platform dependent code.  Threading behaviour was made
      controllable through the introduction of
      taskmasters.  <a href="http://www.cliki.net/mod_lisp">mod_lisp</a>
      support and several other things were removed in this release to
      simplify the code base (and partly due to the lack of interest).
      Several architectural changes (lots of them not
      backwards-compatible) were made to ease customization of
      Hunchentoot's behaviour.  A significant part of the 1.0.0
      redesign was done
      by <a href="http://netzhansa.blogspot.com/">Hans Hübner</a>.
    </p>
  </clix:chapter>

  <clix:chapter name="index" title="Symbol index">

    Here are all exported symbols of the <code>HUNCHENTOOT</code>
    package in alphabetical order linked to their corresponding
    documentation entries:

    <clix:index/>

  </clix:chapter>

  <clix:chapter name="ack" title="Acknowledgements">

    Thanks to Jeff Caldwell - TBNL would not have been released
    without his efforts.  Thanks
    to <a href="http://www.cliki.net/Stefan%20Scholl">Stefan
    Scholl</a> and Travis Cross for various additions and fixes to
    TBNL, to <a href="http://www.foldr.org/~michaelw/">Michael
    Weber</a> for initial file upload code, and
    to <a href="http://www.ltn.lv/~jonis/">Janis Dzerins</a> for
    his <a href="http://common-lisp.net/project/rfc2388/">RFC 2388
    code</a>. Thanks to Bob Hutchison for his code for multiple
    front-ends (which made me realize that TBNL was already pretty
    close to a "real" web server) and the initial UTF-8 example.
    Thanks to <a href="http://netzhansa.blogspot.com/">Hans Hübner</a>
    for a lot of architectural and implementation enhancements for the
    1.0.0 release and also for transferring the documentation to sane
    XHTML.  Thanks to John
    Foderaro's <a href="http://opensource.franz.com/aserve/index.html">AllegroServe</a>
    for inspiration.  Thanks to <a href="http://www.htg1.de/">Uwe von
    Loh</a> for
    the <a href="http://www.htg1.de/hunchentoot/hunchentoot.html">Hunchentoot
    logo</a>.
    
    <p>
      Hunchentoot originally used code
      from <a href="http://www.cliki.net/ACL-COMPAT">ACL-COMPAT</a>,
      specifically the chunking code from Jochen Schmidt.  (This has been
      replaced by <a href="http://weitz.de/chunga/">Chunga</a>.)  When I ported
      Hunchentoot to other Lisps than LispWorks, I stole code from
      ACL-COMPAT, <a href="http://www.cliki.net/kmrcl">KMRCL</a>,
      and <a href="http://www.cliki.net/trivial-sockets">trivial-sockets</a> for
      implementation-dependent stuff like sockets and MP.  (This has been replaced by 
      <a href="http://common-lisp.net/project/bordeaux-threads/">Bordeaux
      Threads</a>
      and <a href="http://common-lisp.net/project/usocket/">usocket</a>.)
    </p>
    <p>
      Parts of this documentation were prepared
      with <a href="http://weitz.de/documentation-template/">DOCUMENTATION-TEMPLATE</a>,
      no animals were harmed.
    </p>
  </clix:chapter>
    <p>$Header: /usr/local/cvsrep/documentation-template/output.lisp,v 1.16 2008/06/01 21:26:20 edi Exp $
    </p>
    <p>
      <a href='http://weitz.de/index.html'>BACK TO MY HOMEPAGE
      </a>
    </p>
  </clix:documentation>
